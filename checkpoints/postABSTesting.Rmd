---
title: "Post-ABS Testing"
author: "Kaija Gahm"
date: '2022-08-09'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, out.width = "100%", message = FALSE)
```

Load some packages that we'll need to use to do these calculations:

```{r warning = FALSE, message = FALSE}
library(tidyverse)
library(gifski)
library(ggraph)
library(here)
library(igraph)
source(here("modelFunction_rewiring.R"))
```

## 1. Run the model once

```{r code_folding = F}
# Define parameters
N = 50
edge.prob <- 0.04
n.removed = 10
burn.in = 20
recovery = 5
add00 = c(0.5, 10)
lose01 = 0.1
add10 = 0.05
lose11 = c(0.5, 0.5)
coefAdd = 0
coefLose = -0
```

```{r}
modelGraphs <- runModel(N = N, # Nodes in the network
                        edge.prob = edge.prob,
                        n.removed = n.removed,
                        burn.in = burn.in,
                        recovery = recovery,
                        add00 = add00, 
                        lose01 = lose01, 
                        add10 = add10,
                        lose11 = lose11,
                        coefAdd = coefAdd,
                        coefLose = coefLose)$graphs

```

## 2. For a single model run, examine network-level measures over time

```{r echo = FALSE}
# DENSITY
densities <- lapply(modelGraphs, function(x){
  edge_density(x)
}) %>% 
  unlist() %>% 
  as.data.frame() %>%
  setNames(., "density") %>%
  mutate(slice = 1:length(modelGraphs))

# Mean distance
meanDistances <- lapply(modelGraphs, function(x){
  mean_distance(x)
}) %>% 
  unlist() %>% 
  as.data.frame() %>%
  setNames(., "meanDistance") %>%
  mutate(slice = 1:length(modelGraphs))

# MODULARITY
clustered <- lapply(modelGraphs, function(x){
  x %>%
    cluster_fast_greedy()
}) 

modularities <- data.frame(slice = 1:length(clustered),
                           modularity = unlist(lapply(clustered, modularity)),
                           nClusters = unlist(lapply(clustered, length)),
                           nIndivs = unlist(lapply(modelGraphs, function(x){length(V(x))})))
```

```{r echo = FALSE}
# Set some colors we can use consistently throughout
densColor <- "#151FC6"
moduColor <- "#C61578"
mdColor <- "#C6BC15"

# DENSITY
densities %>%
  ggplot(aes(x = slice, y = density))+
  geom_line(col = densColor, size = 1)+
  theme_minimal()+
  geom_vline(aes(xintercept = burn.in+1), size = 0.5, lty = 2)+
  ylab("Density")+
  xlab("Time slice")

meanDistances %>%
  ggplot(aes(x = slice, y = meanDistance))+
  geom_line(col = mdColor, size = 1)+
  theme_minimal()+
  geom_vline(aes(xintercept = burn.in+1), size = 0.5, lty = 2)+
  ylab("Mean Distance")+
  xlab("Time slice")

modularities %>%
  ggplot(aes(x = slice, y = modularity))+
  geom_line(col = moduColor, size = 1)+
  theme_minimal()+
  geom_vline(aes(xintercept = burn.in+1), size = 0.5, lty = 2)+
  ylab("Modularity")+
  xlab("Time slice")

modularities %>%
  ggplot(aes(x = slice, y = nClusters))+
  geom_line(col = moduColor, size = 1)+
  theme_minimal()+
  geom_vline(aes(xintercept = burn.in+1), size = 0.5, lty = 2)+
  ylab("Number of clusters")+
  xlab("Time slice")
```

## 3. Trends for many model runs

First, I run the model 100 times and compute the network measures for each of the model runs.

```{r echo = FALSE}
# Run 100 times, using the parameters defined at the very beginning of this document.
nRuns <- 100
modelRuns <- vector(mode = "list", length = nRuns)
for(i in 1:nRuns){
  modelRuns[[i]] <- runModel(N = 50, # Nodes in the network
                             edge.prob = edge.prob,
                             n.removed = n.removed,
                             burn.in = burn.in,
                             recovery = recovery,
                             add00 = add00, 
                             lose01 = lose01, 
                             add10 = add10,
                             lose11 = lose11,
                             coefAdd = coefAdd,
                             coefLose = coefLose)$graphs
}
```

```{r echo = FALSE}
densDF <- lapply(modelRuns, function(x){
    lapply(x, function(y){
      edge_density(y)
    }) %>%
      unlist() %>%
      as.data.frame() %>%
      setNames(., "density") %>%
      mutate(slice = 1:nrow(.))
  }) %>%
  data.table::rbindlist(idcol = "run")

mdDF <- lapply(modelRuns, function(x){
    lapply(x, function(y){
      mean_distance(y)
    }) %>%
      unlist() %>%
      as.data.frame() %>%
      setNames(., "meanDistance") %>%
      mutate(slice = 1:nrow(.))
  }) %>%
  data.table::rbindlist(idcol = "run")

moduDF <- lapply(modelRuns, function(x){
  clustered <- lapply(x, cluster_fast_greedy)
  df <- data.frame(slice = 1:length(clustered),
                       modularity = unlist(lapply(clustered, modularity)),
                       nClusters = unlist(lapply(clustered, length)),
                       nIndivs = unlist(lapply(x, function(x){length(V(x))})))
      return(df)
}) %>%
  data.table::rbindlist(idcol = "run")
```

Now, I can make some plots to detect general trends in what happens to the network after removal/rewiring.
```{r}
# Time slice numbers for line placement
back1 <- which(names(modelGraphs) == "back1") 
removed <- which(names(modelGraphs) == "removed")
rewired <- which(names(modelGraphs) == "rewired")
```

```{r echo = FALSE}
densDF %>%
  ggplot(aes(x = slice, y = density))+
  geom_line(aes(group = run), col = densColor, size = 0.2, alpha = 0.5)+
  theme_minimal()+
  geom_vline(aes(xintercept = removed), size = 0.7, lty = 2)+
  ylab("Density")+
  xlab("Time slice")
```

Density behaves the same no matter the number of individuals in the network, just with less variation. To be expected.

```{r echo = FALSE}
mdDF %>%
  ggplot(aes(x = slice, y = meanDistance))+
  geom_line(aes(group = run), col = mdColor, size = 0.2, alpha = 0.5)+
  theme_minimal()+
  geom_vline(aes(xintercept = burn.in+1), size = 0.7, lty = 2)+
  ylab("Mean Distance")+
  xlab("Time slice")
```

Mean distance looks like it might have a nonlinear relationship with the number of individuals in the network. Need to investigate this further!

```{r echo = FALSE}
moduDF %>%
  ggplot(aes(x = slice, y = modularity))+
  geom_line(aes(group = run), col = moduColor, size = 0.2, alpha = 0.5)+
  theme_minimal()+
  geom_vline(aes(xintercept = burn.in+1), size = 0.7, lty = 2)+
  ylab("Modularity")+
  xlab("Time slice")

moduDF %>%
  filter(slice > 3) %>%
  ggplot(aes(x = slice, y = nClusters))+
  geom_line(aes(group = run), col = moduColor, size = 0.2, alpha = 0.5)+
  theme_minimal()+
  geom_vline(aes(xintercept = burn.in+1), size = 0.7, lty = 2)+
  ylab("Number of clusters")+
  xlab("Time slice")
```

Modularity seems to behave the same no matter the number of individuals in the network.

## 4. Relationship between removed node and network-level measures

```{r echo = FALSE}
# Prepare the data about removed nodes and network-level measures
# NETWORK-LEVEL MEASURES
networkLevel <- left_join(densDF, mdDF, by = c("run", "slice")) %>%
  left_join(moduDF, by = c("run", "slice"))

# NETWORK-LEVEL MEASURE DELTAS (before and after rewiring)
deltas <- networkLevel %>%
  filter(slice %in% c(back1, removed, rewired)) %>%
  group_by(run) %>%
  summarize(dens1 = density[slice == removed]-density[slice == back1],
            dens2 = density[slice == rewired]-density[slice == removed],
            md1 = meanDistance[slice == removed]-meanDistance[slice == back1],
            md2 = meanDistance[slice == rewired]-meanDistance[slice == removed],
            modu1 = modularity[slice == removed]-modularity[slice == back1],
            modu2 = modularity[slice == rewired]-modularity[slice == removed]) %>%
  pivot_longer(cols = -run, names_to = "measure", values_to = "value") %>%
  mutate(type = stringr::str_extract(measure, "[0-9]"),
         measure = stringr::str_remove(measure, "[0-9]")) %>%
  mutate(type = ifelse(type == 1, "Before rewiring", "After rewiring"))

# INFO ABOUT THE REMOVED NODE(S)
removedInfo <- lapply(modelRuns, function(x){
  init <- V(x[[1]])$label
  final <- V(x[[length(x)]])$label
  removedNumbers <- which(!(init %in% final))
  removedNames <- init[!(init %in% final)]
  removedDegrees <- degree(x[[back1]])[removedNumbers]
  removedBetweennesses <- betweenness(x[[back1]])[removedNumbers]
  df <- data.frame(name = removedNames, number = removedNumbers, 
                   degree = removedDegrees,
                   btwn = removedBetweennesses)
  return(df)
}) %>%
  data.table::rbindlist(idcol = "run") %>%
  as.data.frame()

# SUMMARIZE CHARACTERISTICS OF REMOVED NODE(S)
removedInfoSummary <- removedInfo %>%
  group_by(run) %>%
  summarize(meanDeg = mean(degree, na.rm = T),
            meanBtwn = mean(btwn, na.rm = T))


# COMBINE INDIVIDUAL AND NETWORK MEASURES
full <- removedInfoSummary %>%
  left_join(deltas, by = "run") %>%
  mutate(label = case_when(measure == "modu" ~ "\u0394 Modularity",
                           measure == "md" ~ "\u0394 Mean Distance",
                           measure == "dens" ~ "\u0394 Edge Density",
                           TRUE ~ NA_character_))
```

First, let's check whether degree and betweenness are indeed highly correlated. We suspect that they are.

```{r echo = FALSE}
# Degree and betweenness are probably highly correlated. Let's check.
removedInfo %>%
  ggplot(aes(x = degree, y = btwn))+
  geom_point(shape = 1)+
  geom_smooth(method = "lm")+
  theme_minimal()+
  ylab("Betweenness")+
  xlab("Degree")
```

Indeed, these are highly correlated. I'm not going to make graphs for betweenness, just degree.

```{r echo = FALSE}
# Set some common plot elements
plotElements = list(geom_point(shape = 1),
                    geom_smooth(method = "lm", aes(col = label)),
                    scale_color_manual(values = c(mdColor, densColor, moduColor)),
                    facet_wrap(~label, scales = "free", strip.position = "left"),
                    theme_minimal(),
                    theme(strip.placement = "outside",
                          legend.position = "none",
                          axis.title.x = element_text(size = 11),
                          strip.text.y = element_text(size = 11)),
                    ylab(""))

# DEGREE VS. DELTA 1
full %>%
  mutate(label = paste0("|", label, "|")) %>%
  filter(type == "Before rewiring") %>%
  ggplot(aes(x = meanDeg, y = abs(value)))+
  plotElements+
  xlab("Mean degree of removed nodes")+
  ggtitle("Change")

# DEGREE VS. DELTA 2
full %>%
  mutate(label = paste0("|", label, "|")) %>%
  filter(type == "After rewiring") %>%
  ggplot(aes(x = meanDeg, y = abs(value)))+
  plotElements+
  xlab("Mean degree of removed nodes")+
  ggtitle("Recovery")
```

What about the ratio between the first and second changes? Aka: what percentage of the loss/gain is recovered by the rewiring?

```{r echo = FALSE, message = FALSE}
# Create the ratios data to use for these plots
deltaRatios <- full %>%
  group_by(run, meanDeg, meanBtwn, measure, label) %>%
  summarize(ratio = value[2]/value[1],
            absRatio = abs(ratio)) %>%
  mutate(measure = case_when(measure == "modu" ~ "Modularity",
                             measure == "dens" ~ "Density",
                             measure == "md" ~ "Mean Distance",
                             TRUE ~ NA_character_))

# Set some common plot elements
plotElements = list(geom_point(shape = 1),
                    geom_smooth(method = "lm", aes(col = label)),
                    scale_color_manual(values = c(mdColor, densColor, moduColor)),
                    facet_wrap(~measure, scales = "free", strip.position = "left"),
                    theme_minimal(),
                    theme(strip.placement = "outside",
                          legend.position = "none",
                          axis.title.x = element_text(size = 14),
                          strip.text.y = element_text(size = 14)),
                    ylab(""))

# DEGREE VS. DELTA RATIO
deltaRatios %>%
  ggplot(aes(x = meanDeg, y = ratio))+
  plotElements+
  xlab("Mean degree of removed nodes")+
  ggtitle("Change/Recovery")

# DEGREE VS. abs(DELTA RATIO)
deltaRatios %>%
  ggplot(aes(x = meanDeg, y = absRatio))+
  plotElements+
  xlab("Mean degree of removed nodes")+
  ggtitle("|Change/Recovery|")
```
