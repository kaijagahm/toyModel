---
title: "Post-ABS Testing"
author: "Kaija Gahm"
date: '2022-08-09'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, out.width = "100%", message = FALSE)
ggplot2::theme_set(ggplot2::theme_minimal())
```

Load some packages that we'll need to use to do these calculations:

```{r warning = FALSE, message = FALSE}
library(tidyverse)
library(gifski)
library(ggraph)
library(here)
library(igraph)
library(tnet) # for the closeness function described here: https://toreopsahl.com/2010/03/20/closeness-centrality-in-networks-with-disconnected-components/
source(here("modelFunction_rewiring.R"))
```

## 1. Run the model once

```{r code_folding = F}
# Define parameters
N = 50
socAlpha = 2
socBeta = 4
n.removed = 10
burn.in = 10
recovery = 5
mod00 = -0.4
mod01 = 0.2
mod10 = -0.2
mod11 = 0.4
coefBereavement = 1
```

```{r}
modelGraphs <- runModel(N = N, # Nodes in the network
                        socAlpha = socAlpha,
                        socBeta = socBeta,
                        n.removed = n.removed,
                        burn.in = burn.in,
                        recovery = recovery,
                        mod00 = mod00, 
                        mod11 = mod11, 
                        mod10 = mod10, 
                        mod01 = mod01,
                        coefBereavement = coefBereavement)$graphs
```

## 2. Do individuals have differentiable degrees over time?

```{r}
df <- lapply(modelGraphs, degree) %>%
  do.call(rbind, .) %>%
  as.data.frame() %>%
  mutate(timestep = 1:nrow(.)) %>%
  pivot_longer(cols = -timestep, names_to = "id", values_to = "degree") %>%
  group_by(id) %>%
  mutate(initDegree = degree[1]) %>%
  ungroup() %>%
  mutate(id = as.numeric(stringr::str_remove(id, "V")))

df %>%
  ggplot(aes(x = timestep, y = degree, col = initDegree, group = id))+
  geom_line()+
  scale_color_viridis_c()
# yes, we definitely see some individual differences in degree over time. The strength of this effect depends on socAlpha and socBeta.
```

## 3. Trends for many model runs

First, I run the model 100 times and compute the network measures for each of the model runs.

```{r echo = FALSE}
# Run 100 times, using the parameters defined at the very beginning of this document.
nRuns <- 500
modelRuns <- vector(mode = "list", length = nRuns)
for(i in 1:nRuns){
  modelRuns[[i]] <- runModel(N = 50, # Nodes in the network
                             socAlpha = socAlpha,
                             socBeta = socBeta,
                             n.removed = n.removed,
                             id = NULL,
                             burn.in = burn.in,
                             recovery = recovery,
                             mod00 = mod00, 
                             mod01 = mod01, 
                             mod10 = mod10,
                             mod11 = mod11,
                             coefBereavement)$graphs
}
```

```{r echo = FALSE}
densColor <- "#151FC6"
moduColor <- "#C61578"
mdColor <- "#C6BC15"
densDF <- lapply(modelRuns, function(x){
    lapply(x, function(y){
      edge_density(y)
    }) %>%
      unlist() %>%
      as.data.frame() %>%
      setNames(., "density") %>%
      mutate(slice = 1:nrow(.))
  }) %>%
  data.table::rbindlist(idcol = "run")

mdDF <- lapply(modelRuns, function(x){
    lapply(x, function(y){
      mean_distance(y)
    }) %>%
      unlist() %>%
      as.data.frame() %>%
      setNames(., "meanDistance") %>%
      mutate(slice = 1:nrow(.))
  }) %>%
  data.table::rbindlist(idcol = "run")

moduDF <- lapply(modelRuns, function(x){
  clustered <- lapply(x, cluster_fast_greedy)
  df <- data.frame(slice = 1:length(clustered),
                       modularity = unlist(lapply(clustered, modularity)),
                       nClusters = unlist(lapply(clustered, length)),
                       nIndivs = unlist(lapply(x, function(x){length(V(x))})))
      return(df)
}) %>%
  data.table::rbindlist(idcol = "run")
```

Now, I can make some plots to detect general trends in what happens to the network after removal/rewiring.
```{r}
# Time slice numbers for line placement
back1 <- which(names(modelGraphs) == "back1") 
removed <- which(names(modelGraphs) == "removed")
rewired <- which(names(modelGraphs) == "rewired")
```

```{r echo = FALSE}
densDF %>%
  group_by(slice) %>%
  mutate(avg = mean(density)) %>%
  ungroup() %>%
  ggplot(aes(x = slice, y = density))+
  geom_line(aes(group = run), col = densColor, size = 0.2, alpha = 0.2)+
  geom_line(aes(x = slice, y = avg), col = "black", size = 0.9)+
  
  geom_vline(aes(xintercept = burn.in+1), size = 0.7, lty = 2)+
  ylab("Density")+
  xlab("Time slice")
```

There's no overall pattern to the effect of loss or rewiring on the network density. Presumably, if loss or rewiring does affect density, the extent of the effect will depend on which individuals were removed, or on some other factor. It isn't generalizable.

```{r echo = FALSE}
mdDF %>%
  group_by(slice) %>%
  mutate(avg = mean(meanDistance)) %>%
  ungroup() %>%
  ggplot(aes(x = slice, y = meanDistance))+
  geom_line(aes(group = run), col = mdColor, size = 0.2, alpha = 0.2)+
  geom_line(aes(x = slice, y = avg), col = "black", size = 0.9)+
  geom_vline(aes(xintercept = burn.in+1), size = 0.7, lty = 2)+
  ylab("Mean Distance")+
  xlab("Time slice")
```

In general, mean distance increases when individuals are removed, though it looks like there's a lot of variation in the extent of the increase, and there are some cases where it decreases.

```{r echo = FALSE}
moduDF %>%
  group_by(slice) %>%
  mutate(avg = mean(modularity)) %>%
  ungroup() %>%
  ggplot(aes(x = slice, y = modularity))+
  geom_line(aes(group = run), col = moduColor, size = 0.2, alpha = 0.2)+
  geom_line(aes(x = slice, y = avg), col = "black", size = 0.9)+
  geom_vline(aes(xintercept = burn.in+1), size = 0.7, lty = 2)+
  ylab("Modularity")+
  xlab("Time slice")

moduDF %>%
  group_by(slice) %>%
  mutate(avg = mean(nClusters/nIndivs)) %>%
  ungroup() %>%
  filter(slice > 3) %>%
  ggplot(aes(x = slice, y = nClusters/nIndivs))+
  geom_line(aes(group = run), col = moduColor, size = 0.2, alpha = 0.2)+
  geom_line(aes(x = slice, y = avg), col = "black", size = 0.9)+
  geom_vline(aes(xintercept = burn.in+1), size = 0.7, lty = 2)+
  ylab("Clusters per individual")+
  xlab("Time slice")

moduDF %>%
  group_by(slice) %>%
  mutate(avg = mean(nIndivs/nClusters)) %>%
  ungroup() %>%
  filter(slice > 3) %>%
  ggplot(aes(x = slice, y = nIndivs/nClusters))+
  geom_line(aes(group = run), col = moduColor, size = 0.2, alpha = 0.2)+
  geom_line(aes(x = slice, y = avg), col = "black", size = 0.9)+
  geom_vline(aes(xintercept = burn.in+1), size = 0.7, lty = 2)+
  ylab("Individuals per cluster")+
  xlab("Time slice")
```

Modularity generally increases when individuals are removed and declines again with rewiring, but that's not universally the case.

## 4. Relationship between removed nodes and network-level measures

```{r echo = FALSE}
# Prepare the data about removed nodes and network-level measures
# NETWORK-LEVEL MEASURES
networkLevel <- left_join(densDF, mdDF, by = c("run", "slice")) %>%
  left_join(moduDF, by = c("run", "slice"))

# NETWORK-LEVEL MEASURE DELTAS (before and rewiring)
deltas <- networkLevel %>%
  filter(slice %in% c(back1, removed, rewired)) %>%
  group_by(run) %>%
  summarize(dens1 = density[slice == removed]-density[slice == back1],
            dens2 = density[slice == rewired]-density[slice == removed],
            md1 = meanDistance[slice == removed]-meanDistance[slice == back1],
            md2 = meanDistance[slice == rewired]-meanDistance[slice == removed],
            modu1 = modularity[slice == removed]-modularity[slice == back1],
            modu2 = modularity[slice == rewired]-modularity[slice == removed]) %>%
  pivot_longer(cols = -run, names_to = "yMeasure", values_to = "yMeasureValue") %>%
  mutate(change = stringr::str_extract(yMeasure, "[0-9]"),
         yMeasure = stringr::str_remove(yMeasure, "[0-9]")) %>%
  mutate(change = ifelse(change == 1, "removal", "rewiring"))

# INFO ABOUT THE REMOVED NODE(S)
removedInfo <- lapply(modelRuns, function(x){
  init <- V(x[[1]])$label
  final <- V(x[[length(x)]])$label
  removedNumbers <- which(!(init %in% final))
  removedNames <- init[!(init %in% final)]
  removedDegrees <- degree(x[["back1"]])[removedNumbers]
  removedBetweennesses <- betweenness(x[["back1"]])[removedNumbers]
  
  # Calculate "the extent to which the removed nodes constitute their own cluster"
  membershipVec <- as.vector(V(x[[1]]))
  membershipVec[removedNumbers] <- 1
  membershipVec[-removedNumbers] <- 2
  # created a cluster membership vector, assigning each of the removed nodes to cluster "1" and each of the remaining nodes to cluster "2"
  
  mod <- modularity(x[["back1"]], membership = membershipVec)
  
  # Make edge list for calculating closenesses
  el <- get.edgelist(x[["back1"]], names = TRUE) %>%
    cbind(., 1) %>%
    as_tibble() %>%
    complete(V1 = 1:max(V(x[["back1"]])), V2 = 1:max(V(x[["back1"]])), fill = list(V3 = 0))
  
  ## calculate closenesses
  closenesses <- as.data.frame(suppressWarnings(closeness_w(el, directed = FALSE, gconly = FALSE)))
  removedClosenesses <- closenesses %>%
    filter(node %in% removedNumbers)
  
  # Pairwise distance matrix for only the about-to-be-removed nodes
  removedDistances <- distances(x[["back1"]])[removedNumbers, removedNumbers]
  removedDistances[removedDistances == 0|is.infinite(removedDistances)] <- NA
  removedDistances[lower.tri(removedDistances)] <- NA # consider only one triangle, since this is undirected
  removedMeanDistance <- mean(removedDistances, na.rm = T)
  
  removedGraph <- subgraph(x[[back1]], vids = removedNumbers)
  df <- data.frame(name = removedNames, 
                   number = removedNumbers, 
                   degree = removedDegrees,
                   fullGraphDens = edge_density(x[["back1"]]),
                   btwn = removedBetweennesses,
                   dens = edge_density(removedGraph),
                   meanDist = removedMeanDistance,
                   mod = mod)
  df <- df %>%
    left_join(removedClosenesses, by = c("number" = "node"))
  
  return(df)
}) %>%
  data.table::rbindlist(idcol = "run") %>%
  as.data.frame()

# SUMMARIZE CHARACTERISTICS OF REMOVED NODE(S)
removedInfoSummary <- removedInfo %>%
  group_by(run) %>%
  summarize(meanDeg = mean(degree, na.rm = T),
            meanBtwn = mean(btwn, na.rm = T),
            dens = dens[1],
            mod = mod[1],
            fullGraphDens = fullGraphDens[1],
            meanDist = meanDist[1],
            meanCloseness = mean(closeness, na.rm = T),
            meanNormalizedCloseness = mean(n.closeness, na.rm = T))

# COMBINE INDIVIDUAL AND NETWORK MEASURES
full <- removedInfoSummary %>%
  left_join(deltas, by = "run") %>%
  mutate(label = case_when(yMeasure == "modu" ~ "\u0394 Modularity",
                           yMeasure == "md" ~ "\u0394 Mean Distance",
                           yMeasure == "dens" ~ "\u0394 Edge Density",
                           TRUE ~ NA_character_))
```

A few sanity checks:

```{r echo = FALSE}
# Are degree and betweenness highly correlated?
removedInfo %>%
  ggplot(aes(x = jitter(degree), y = btwn))+
  geom_point(shape = 1)+
  geom_smooth(method = "lm")+
  ylab("Betweenness")+
  xlab("Degree")
# yes, they are!

# Is there a relationship between the density of the entire graph and the mean distance between the removed nodes? Suspect a negative relationship
full %>% 
  select(run, meanDeg, meanBtwn, dens, fullGraphDens, meanDist) %>%
  distinct() %>%
  ggplot(aes(x = fullGraphDens, y = meanDist, col = dens))+
  geom_point(size = 2)+
  theme_minimal()+
  geom_smooth(method = "lm")+
  scale_color_viridis_c(name = "Density \n(removed \nnodes)")+
  ylab("Mean distance (removed nodes)")+
  xlab("Density (full graph)")
# Indeed, we see a fairly strong negative relationship here. Also see that there's some pattern in the densities of the subgraphs of removed nodes.

# Do denser graphs also have denser subgraphs of removed nodes? (Expect a positive relationship, based on the colors in the previous plot.)
full %>% 
  select(run, meanDeg, meanBtwn, dens, fullGraphDens, meanDist) %>%
  distinct() %>%
  ggplot(aes(x = fullGraphDens, y = dens))+
  geom_point(size = 2, alpha = 0.5)+
  geom_smooth(method = "lm")+
  theme_minimal()+
  ylab("Density (removed nodes)")+
  xlab("Density (full graph)")
# There is a slight positive relationship between the density of the overall graph and the density of the removed nodes, but it is not particularly strong, and there's a ton of variability.

# Is there indeed an inverse relationship between the mean degree of the removed nodes and their mean distance?
full %>%
  select(run, meanDeg, meanBtwn, dens, fullGraphDens, meanDist) %>%
  distinct() %>%
  ggplot(aes(x = jitter(meanDeg), y = meanDist, col = dens))+
  scale_color_viridis_c(name = "Density \n(removed \nnodes)")+
  geom_point(size = 2)+
  geom_smooth(method = "lm")+
  theme_minimal()+
  ylab("Mean distance (removed nodes)")+
  xlab("Mean degree (removed nodes)")
# As expected, the more connected removal subgraphs have shorter distances between nodes, and this also generally a higher density. This all checks out.
# Note that this correlation is stronger than I expected it to be, which makes me wonder if mean degree is not actually such a bad measure for our x axis. 

# Now let's look at the relationship between density and mean distance
full %>%
  select(run, meanDeg, meanBtwn, dens, fullGraphDens, meanDist) %>%
  distinct() %>%
  ggplot(aes(x = jitter(dens), y = meanDist))+
  geom_point(size = 2)+
  geom_smooth(method = "lm")+
  theme_minimal()+
  ylab("Mean distance (removed nodes)")+
  xlab("Density (removed nodes)")
# As expected, higher density of the removed nodes correlates with lower mean distance between them. 

# Because closeness is just another way of measuring mean distance (albeit calculated with reciprocals so maybe a bit different), I expect these two to be pretty closely related.
full %>%
  select(run, meanDeg, meanDist, meanCloseness, meanNormalizedCloseness) %>%
  distinct() %>%
  ggplot(aes(x = meanDist, y = meanCloseness, col = meanDeg))+
  scale_color_viridis_c()+
  geom_point(size = 2)+
  geom_smooth(method = "lm")+
  theme_minimal()+
  ylab("Mean distance (removed nodes)")+
  xlab("Mean closeness (removed nodes)")
# indeed, these are definitely correlated, though not as tightly as I would have assumed. I bet that's because of the reciprocal thing or the way the zeroes are calculated. The variation is probably largely attributable to variation in the number of isolated nodes. Indeed, this is confirmed by the smooth color gradient of mean degree. 

# I checked out the graph for normalized closeness and it's exactly the same--that's because all of these networks have the same number of nodes. This suggests we should use normalized closeness, in case we want to compare across networks with different numbers of nodes later.

# What is the overall modularity of the removed nodes? Should be a normal distribution, since the nodes were removed randomly.
hist(removedInfoSummary$mod) # cool, this looks reasonable. Normal distribution centered around zero.

# What is the relationship between the modularity and other measures?
# Predict that when the nodes constitute more of a module, they will have a higher density
removedInfoSummary %>%
  ggplot(aes(x = mod, y = dens))+
  geom_point(shape = 21)+
  geom_smooth(method = "lm")

# Predict that when the nodes constitute more of a module, they will have a lower mean closeness
removedInfoSummary %>%
  ggplot(aes(x = mod, y = meanNormalizedCloseness))+
  geom_point(shape = 21)+
  geom_smooth(method = "lm")
# huh, there's no apparent relationship between these, and if there's any relationship at all it's in the opposite direction than I would have expected. I don't understand why that is.

# What about degree and betweenness?
# I predict no relationship between mean degree or mean betweenness and modularity
removedInfoSummary %>%
  ggplot(aes(x = mod, y = meanDeg))+
  geom_point(shape = 21)+
  geom_smooth(method = "lm") # as predicted, no relationship. Good! They're measuring different things.

removedInfoSummary %>%
  ggplot(aes(x = mod, y = meanBtwn))+
  geom_point(shape = 21)+
  geom_smooth(method = "lm") # okay, something of a negative relationship with betweenness. I guess that makes sense--nodes that are more out of the way might be more modular with each other and less well connected to the rest of the graph. But the relationship is weak.

# So, it seems reasonable to use modularity as an addition to/alternative to mean degree or mean closeness.

# I think mean closeness is actually a better measure of what I care about here. Q1: "how generally well-connected/central were the removed nodes on the network before they died?" and closeness is a fairly good measure of that that takes into account their closeness to others beyond their immediate neighbors.
# For Q2: "how much of a clique did the removed individuals form (i.e. how separate were they from the rest of the network)?", modularity seems to be a fairly okay measure.
```

```{r echo = FALSE}
# Set some common plot elements
plotElements = list(geom_point(shape = 1),
                    geom_smooth(method = "lm", aes(col = label)),
                    scale_color_manual(values = c(densColor, mdColor, moduColor)),
                    facet_wrap(~label, scales = "free", strip.position = "left"),
                    theme(strip.placement = "outside",
                          legend.position = "none",
                          axis.title.x = element_text(size = 11),
                          strip.text.y = element_text(size = 11)),
                    ylab(""))

# REMOVAL (REMOVED - BACK1)
full %>%
  filter(change == "removal") %>%
  ggplot(aes(x = meanDeg, y = yMeasureValue))+
  geom_point(alpha = 0.5, shape = 1)+
  plotElements+
  xlab("Mean degree of removed nodes")+
  ggtitle("REMOVAL")

full %>%
  filter(change == "removal") %>%
  ggplot(aes(x = meanDist, y = yMeasureValue))+
  geom_point(alpha = 0.5, shape = 1)+
  plotElements+
  xlab("Mean distance between removed nodes")+
  ggtitle("REMOVAL")

full %>%
  filter(change == "removal") %>%
  ggplot(aes(x = meanNormalizedCloseness, y = yMeasureValue))+
  geom_point(alpha = 0.5, shape = 1)+
  plotElements+
  xlab("Mean normalized closeness of removed nodes")+
  ggtitle("REMOVAL")

# REWIRING (REWIRED - REMOVED)
full %>%
  filter(change == "rewiring") %>%
  ggplot(aes(x = meanDeg, y = yMeasureValue))+
  geom_point(alpha = 0.5, shape = 1)+
  plotElements+
  xlab("Mean degree of removed nodes")+
  ggtitle("REWIRING")

full %>%
  filter(change == "rewiring") %>%
  ggplot(aes(x = meanDist, y = yMeasureValue))+
  geom_point(alpha = 0.5, shape = 1)+
  plotElements+
  xlab("Mean distance between removed nodes")+
  ggtitle("REWIRING")

full %>%
  filter(change == "rewiring") %>%
  ggplot(aes(x = meanNormalizedCloseness, y = yMeasureValue))+
  geom_point(alpha = 0.5, shape = 1)+
  plotElements+
  xlab("Mean normalized closeness of removed nodes")+
  ggtitle("REWIRING")

# Mean degree and mean distance are basically inverses of each other for removal. For rewiring, they are much more similar, although there's some differentiation in direction. 
```

What about the ratio between the first and second changes? Aka: what percentage of the loss/gain is recovered by the rewiring?

```{r echo = FALSE, message = FALSE}
# Create the ratios data to use for these plots
deltaRatios <- full %>%
  group_by(run, meanDeg, meanBtwn, meanCloseness, meanNormalizedCloseness, dens, fullGraphDens, meanDist, yMeasure, label) %>%
  summarize(val1 = yMeasureValue[1],
            val2 = yMeasureValue[2],
            ratio = val2/val1,
            absRatio = abs(ratio)) %>%
  mutate(yMeasure = case_when(yMeasure == "modu" ~ "Modularity",
                             yMeasure == "dens" ~ "Density",
                             yMeasure == "md" ~ "Mean Distance",
                             TRUE ~ NA_character_))

# Set some common plot elements
plotElements = list(geom_point(shape = 1),
                    geom_smooth(method = "lm", aes(col = label)),
                    scale_color_manual(values = c(mdColor, densColor, moduColor)),
                    facet_wrap(~yMeasure, scales = "free", strip.position = "left"),
                    theme(strip.placement = "outside",
                          legend.position = "none",
                          axis.title.x = element_text(size = 14),
                          strip.text.y = element_text(size = 14)),
                    ylab(""))

# MEAN DEGREE VS. DELTA RATIO
deltaRatios %>%
  ggplot(aes(x = meanDeg, y = log(ratio)))+
  plotElements+
  xlab("Mean degree of removed nodes")+
  ggtitle("log(Rewiring/Removal)")

# MEAN DISTANCE VS. DELTA RATIO
deltaRatios %>%
  ggplot(aes(x = meanDist, y = log(ratio)))+
  plotElements+
  xlab("Mean distance between removed nodes")+
  ggtitle("log(Rewiring/Removal)")

# MEAN CLOSENESS (NORMALIZED) VS. DELTA RATIO
deltaRatios %>%
  ggplot(aes(x = meanNormalizedCloseness, y = log(ratio)))+
  plotElements+
  xlab("Mean normalized closeness of removed nodes")+
  ggtitle("log(Rewiring/Removal)")

# MEAN DEGREE VS. abs(DELTA RATIO)
deltaRatios %>%
  ggplot(aes(x = meanDeg, y = log(absRatio)))+
  plotElements+
  xlab("Mean degree of removed nodes")+
  ggtitle("log(|Rewiring/Removal|)")

# MEAN DISTANCE VS. abs(DELTA RATIO)
deltaRatios %>%
  ggplot(aes(x = meanDist, y = log(absRatio)))+
  plotElements+
  xlab("Mean distance between removed nodes")+
  ggtitle("log(|Rewiring/Removal|)")

# MEAN CLOSENESS (NORMALIZED) VS. abs(DELTA RATIO)
deltaRatios %>%
  ggplot(aes(x = meanNormalizedCloseness, y = log(absRatio)))+
  plotElements+
  xlab("Mean normalized closeness of removed nodes")+
  ggtitle("log(|Rewiring/Removal|od)")
```

Gain vs. keep edges

What proportion of previous edges did bereaved individuals keep? And did it change by how bereaved they were?

```{r}

```

