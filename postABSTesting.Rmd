---
title: "Post-ABS Testing"
author: "Kaija Gahm"
date: '2022-08-09'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, out.width = "100%", message = FALSE)
```

Load some packages that we'll need to use to do these calculations:

```{r warning = FALSE, message = FALSE}
library(tidyverse)
library(gifski)
library(ggraph)
library(here)
library(igraph)
source(here("modelFunction_rewiring.R"))
```

## 1. Run the model once

```{r code_folding = F}
# Define parameters
N = 50
edge.prob <- 0.04
burn.in = 20
burn.out = 5
pm = 0.3
ps = 0.1
pa = 0.2
add00 = c(0.5, 10)
lose01 = 0.1
add10 = 0.05
lose11 = c(0.5, 0.5)
histMultiplier = 1.2
doRemoval = TRUE
```

```{r}
modelGraphs <- runModel(N = N, # Nodes in the network
                        edge.prob = edge.prob, 
                        burn.in = burn.in,
                        burn.out = burn.out,
                        pm = pm,
                        ps = ps, 
                        pa = pa,
                        add00 = add00, 
                        lose01 = lose01, 
                        add10 = add10,
                        lose11 = lose11, 
                        histMultiplier = histMultiplier,
                        doRemoval = doRemoval) %>%
  lapply(., function(x){
    igraph::graph_from_adjacency_matrix(x, mode = "undirected", add.colnames = "label")
  })

```

## 2. How does variation in degree and betweenness emerge in this model?

Because I have not given individuals different tendencies to associate with others, we don't expect to see consistent individual variation in betweenness or degree. It should emerge in each time slice from the random interactions, but there's no reason it should be consistent across time slices.

Compute degree and betweenness for each of the model networks, and visualize how they change over time.

```{r echo = FALSE}
attrDF <- lapply(modelGraphs, function(x){
  x %>%
    set_vertex_attr(., name = "degree", value = degree(x)) %>%
    set_vertex_attr(., name = "betweenness", value = betweenness(x)) %>%
    tidygraph::as_tbl_graph() %>%
    tidygraph::activate(nodes) %>%
    data.frame()
}) %>%
  data.table::rbindlist(idcol = "slice") %>%
  as.data.frame() %>%
  mutate(beforeAfter = ifelse(slice <= burn.in, "before", "after"))

# make a long-format version to use for facetted plots
attrDFLong <- attrDF %>%
  pivot_longer(cols = c(degree, betweenness), names_to = "measure", values_to = "value")
```

```{r echo = FALSE}
# Degree and betweenness over time
attrDFLong %>%
  ggplot(aes(x = slice, y = value, col = label, group = label))+
  facet_wrap(~measure, scales = "free")+
  geom_line(alpha = 0.7, size = 0.5)+
  theme_minimal()+
  geom_vline(xintercept = burn.in+1, col = "red", size = 1)+
  theme(legend.position = "none")

# Let's just look at a few labels, because this plot is too hard to read
indivs <- sample(unique(attrDFLong$label), 5)
attrDFLong %>%
  filter(label %in% indivs) %>%
  ggplot(aes(x = slice, y = value, col = label, group = label))+
  facet_wrap(~measure, scales = "free")+
  geom_line()+
  theme_minimal()+
  geom_vline(xintercept = burn.in+1, col = "red", size = 1)

# Okay, I'm seeing some differentiation, but no clear patterns. Because of how the model is set up, the rank order tends to be maintained for a few consecutive time steps, but not over the whole span of the baseline model. This makes sense, since labels don't have any a priori reason to have higher or lower degrees than other labels.
```

## 3. For a single model run, examine network-level measures over time

```{r echo = FALSE}
# DENSITY
densities <- lapply(modelGraphs, function(x){
  edge_density(x)
}) %>% 
  unlist() %>% 
  as.data.frame() %>%
  setNames(., "density") %>%
  mutate(slice = 1:length(modelGraphs))

# Mean distance
meanDistances <- lapply(modelGraphs, function(x){
  mean_distance(x)
}) %>% 
  unlist() %>% 
  as.data.frame() %>%
  setNames(., "meanDistance") %>%
  mutate(slice = 1:length(modelGraphs))

# MODULARITY
clustered <- lapply(modelGraphs, function(x){
  x %>%
    cluster_fast_greedy()
}) 

modularities <- data.frame(slice = 1:length(clustered),
                           modularity = unlist(lapply(clustered, modularity)),
                           nClusters = unlist(lapply(clustered, length)),
                           nIndivs = unlist(lapply(clustered, function(x){length(membership(x))})))
```

```{r echo = FALSE}
# Set some colors we can use consistently throughout
densColor <- "#151FC6"
moduColor <- "#C61578"
mdColor <- "#C6BC15"

# DENSITY
densities %>%
  ggplot(aes(x = slice, y = density))+
  geom_line(col = densColor, size = 1)+
  theme_minimal()+
  geom_vline(aes(xintercept = burn.in+1), size = 0.5, lty = 2)+
  ylab("Density")+
  xlab("Time slice")

meanDistances %>%
  ggplot(aes(x = slice, y = meanDistance))+
  geom_line(col = mdColor, size = 1)+
  theme_minimal()+
  geom_vline(aes(xintercept = burn.in+1), size = 0.5, lty = 2)+
  ylab("Mean Distance")+
  xlab("Time slice")

modularities %>%
  ggplot(aes(x = slice, y = modularity))+
  geom_line(col = moduColor, size = 1)+
  theme_minimal()+
  geom_vline(aes(xintercept = burn.in+1), size = 0.5, lty = 2)+
  ylab("Modularity")+
  xlab("Time slice")

modularities %>%
  ggplot(aes(x = slice, y = nClusters))+
  geom_line(col = moduColor, size = 1)+
  theme_minimal()+
  geom_vline(aes(xintercept = burn.in+1), size = 0.5, lty = 2)+
  ylab("Number of clusters")+
  xlab("Time slice")
```

## 4. Exploring modularity

### a. How does `cluster_fast_greedy()` deal with isolated nodes?

```{r echo = FALSE}
nIsolatedNodes <- lapply(modelGraphs, function(x){
  sum(degree(x) == 0)
}) %>% 
  unlist()

plot(nIsolatedNodes ~ c(1:length(nIsolatedNodes)), type = "l", ylab = "# isolated nodes", xlab = "Time slice")
```

We can see from this plot that throughout the model, we have some isolated nodes.

The question is, what does the clustering algorithm do to them?

Well, we can also see that there are clusters of size 1:

```{r echo = FALSE}
nSingletonClusters <- lapply(clustered, function(x){
  sum(sizes(x) == 1)
}) %>% 
  unlist()

plot(nSingletonClusters ~ c(1:length(nSingletonClusters)), type = "l", ylab = "# clusters of size 1", xlab = "Time slice")
```

Indeed, there's a clear 1:1 relationship:

```{r}
df <- data.frame(slice = 1:length(nIsolatedNodes),
                 nIsolatedNodes = nIsolatedNodes,
                 nSingletonClusters = nSingletonClusters)

df %>%
  ggplot(aes(x = nIsolatedNodes, y = nSingletonClusters))+
  geom_point()+
  geom_line()+
  theme_minimal()
```

This means that isolated nodes are treated as their own clusters by the clustering algorithm.

(Note: this also suggests that in this model, a connected node will never be its own cluster. I don't think I can conclude that this is true over the whole parameter space of this model. But it's true at least at these sizes of N and connection probabilities.)

Okay, so, these isolated nodes could be affecting the modularity calculations. What if we compute modularity on networks with the isolated nodes removed?

### b. Modularity when ignoring isolated nodes

```{r echo = FALSE}
noIso <- lapply(modelGraphs, function(x){
  g <- delete_vertices(x, which(degree(x) == 0))
})
```

How does modularity behave over time when we remove isolated nodes?

```{r warning = FALSE}
clustered_noIso <- lapply(noIso, function(x){
  cluster_fast_greedy(x)
})

mods_noIso <- data.frame(slice = 1:length(clustered_noIso),
                         modularity = unlist(lapply(clustered_noIso, modularity)),
                         nClusters = unlist(lapply(clustered_noIso, length)),
                         nIndivs = unlist(lapply(clustered_noIso, function(x){length(membership(x))})))

allModularities <- bind_rows(modularities %>% mutate(allowIso = "Original networks"),
                             mods_noIso %>% mutate(allowIso = "Isolated nodes removed"))

allModularities %>%
  ggplot(aes(x = slice, y = modularity, col = allowIso))+
  geom_line(col = moduColor, size = 1)+
  theme_minimal()+
  facet_wrap(~allowIso)+
  geom_vline(aes(xintercept = burn.in+1), size = 0.5, lty = 2)+
  ylab("Modularity")+
  xlab("Time slice")
```

These graphs are exactly the same! It seems that isolated nodes are being treated as their own clusters, but they are not affecting the modularity calculation.

To understand this, I need to go back to the mathematical formula that is being used here. But I suspect it has something to do with 0's and 1's and the ratios between them all working out nicely. To discuss more with Noa.

## 5. Trends for many model runs

First, I run the model 100 times and compute the network measures for each of the model runs.

```{r echo = FALSE}
# Run 100 times, using the parameters defined at the very beginning of this document.
nRuns <- 100
modelRuns <- vector(mode = "list", length = nRuns)
for(i in 1:nRuns){
  modelRuns[[i]] <- runModel(N = N, # Nodes in the network
                             edge.prob = edge.prob, 
                             burn.in = burn.in,
                             burn.out = burn.out,
                             pm = pm,
                             ps = ps, 
                             pa = pa,
                             add00 = add00, 
                             lose01 = lose01, 
                             add10 = add10,
                             lose11 = lose11, 
                             histMultiplier = histMultiplier,
                             doRemoval = doRemoval) %>%
    lapply(., function(x){
      igraph::graph_from_adjacency_matrix(x, mode = "undirected")
    })
}
```

```{r echo = FALSE}
# Compute network-level measures for each model run
densList <- lapply(modelRuns, function(x){
  lapply(x, function(y){
    edge_density(y)
  }) %>%
    unlist() %>%
    as.data.frame() %>%
    setNames(., "density") %>%
    mutate(slice = 1:nrow(.))
})
densDF <- data.table::rbindlist(densList, idcol = "run")

mdList <- lapply(modelRuns, function(x){
  lapply(x, function(y){
    mean_distance(y)
  }) %>%
    unlist() %>%
    as.data.frame() %>%
    setNames(., "meanDistance") %>%
    mutate(slice = 1:nrow(.))
})
mdDF <- data.table::rbindlist(mdList, idcol = "run")

moduList <- lapply(modelRuns, function(x){
  clustered <- lapply(x, cluster_fast_greedy)
  df <- data.frame(slice = 1:length(clustered),
                   modularity = unlist(lapply(clustered, modularity)),
                   nClusters = unlist(lapply(clustered, length)),
                   nIndivs = unlist(lapply(clustered, function(i){length(membership(i))})))
  return(df)
})
moduDF <- data.table::rbindlist(moduList, idcol = "run")
```

Now, I can make some plots to detect general trends in what happens to the network after removal/rewiring.

```{r}
densDF %>%
  ggplot(aes(x = slice, y = density))+
  geom_line(aes(group = run), col = densColor, size = 0.2, alpha = 0.5)+
  theme_minimal()+
  geom_vline(aes(xintercept = burn.in+1), size = 0.7, lty = 2)+
  scale_color_viridis_c()+
  ylab("Density")+
  xlab("Time slice")

mdDF %>%
  ggplot(aes(x = slice, y = meanDistance))+
  geom_line(aes(group = run), col = mdColor, size = 0.2, alpha = 0.5)+
  theme_minimal()+
  geom_vline(aes(xintercept = burn.in+1), size = 0.7, lty = 2)+
  scale_color_viridis_c()+
  ylab("Mean Distance")+
  xlab("Time slice")

moduDF %>%
  ggplot(aes(x = slice, y = modularity))+
  geom_line(aes(group = run), col = moduColor, size = 0.2, alpha = 0.5)+
  theme_minimal()+
  geom_vline(aes(xintercept = burn.in+1), size = 0.7, lty = 2)+
  scale_color_viridis_c() +
  ylab("Modularity")+
  xlab("Time slice")

moduDF %>%
  filter(slice > 3) %>%
  ggplot(aes(x = slice, y = nClusters))+
  geom_line(aes(group = run), col = moduColor, size = 0.2, alpha = 0.5)+
  theme_minimal()+
  geom_vline(aes(xintercept = burn.in+1), size = 0.7, lty = 2)+
  scale_color_viridis_c()+
  ylab("Number of clusters")+
  xlab("Time slice")
```

## 6. Relationship between removed node and network-level measures

```{r echo = FALSE}
# Prepare the data about removed nodes and network-level measures

# NETWORK-LEVEL MEASURES
networkLevel <- left_join(densDF, mdDF, by = c("run", "slice")) %>%
  left_join(moduDF, by = c("run", "slice"))

# NETWORK-LEVEL MEASURE DELTAS (before and after rewiring)
deltas <- networkLevel %>%
  filter(slice %in% c(burn.in, burn.in+1, burn.in+2)) %>%
  group_by(run) %>%
  summarize(dens1 = density[2]-density[1],
            dens2 = density[3]-density[2],
            md1 = meanDistance[2]-meanDistance[1],
            md2 = meanDistance[3]-meanDistance[2],
            modu1 = modularity[2]-modularity[1],
            modu2 = modularity[3]-modularity[2]) %>%
  pivot_longer(cols = -run, names_to = "measure", values_to = "value") %>%
  mutate(type = stringr::str_extract(measure, "[0-9]"),
         measure = stringr::str_remove(measure, "[0-9]")) %>%
  mutate(type = ifelse(type == 1, "Before rewiring", "After rewiring"))
  
# INFO ABOUT THE REMOVED NODE
removedInfo <- lapply(modelRuns, function(x){
  init <- V(x[[1]])$name
  final <- V(x[[length(x)]])$name
  removedNumber <- which(!(init %in% final))
  removedName <- init[!(init %in% final)]
  removedDegree <- degree(x[[burn.in]])[removedNumber]
  removedBetweenness <- betweenness(x[[burn.in]])[removedNumber]
  df <- data.frame(name = removedName, number = removedNumber, 
                   degree = removedDegree,
                   btwn = removedBetweenness)
  return(df)
}) %>%
  data.table::rbindlist(idcol = "run") %>%
  as.data.frame()

# COMBINE INDIVIDUAL AND NETWORK MEASURES
full <- removedInfo %>%
  left_join(deltas, by = "run") %>%
  mutate(label = case_when(measure == "modu" ~ "\u0394 Modularity",
                           measure == "md" ~ "\u0394 Mean Distance",
                           measure == "dens" ~ "\u0394 Edge Density",
                           TRUE ~ NA_character_))
```

First, let's check whether degree and betweenness are indeed highly correlated. We suspect that they are.

```{r echo = FALSE}
# Degree and betweenness are probably highly correlated. Let's check.
removedInfo %>%
  ggplot(aes(x = degree, y = btwn))+
  geom_point(shape = 1)+
  geom_smooth(method = "lm")+
  theme_minimal()+
  ylab("Betweenness")+
  xlab("Degree")
```

Indeed, these are highly correlated. I'm not going to make graphs for betweenness, just degree.

```{r echo = FALSE}
# Set some common plot elements
plotElements = list(geom_point(shape = 1),
             geom_smooth(method = "lm", aes(col = label)),
             scale_color_manual(values = c(mdColor, densColor, moduColor)),
             facet_wrap(~label, scales = "free", strip.position = "left"),
             theme_minimal(),
             theme(strip.placement = "outside",
                   legend.position = "none",
                   axis.title.x = element_text(size = 11),
                   strip.text.y = element_text(size = 11)),
             ylab(""))

# DEGREE VS. DELTA 1
full %>%
  mutate(label = paste0("|", label, "|")) %>%
  filter(type == "Before rewiring") %>%
  ggplot(aes(x = degree, y = abs(value)))+
  plotElements+
  xlab("Degree of removed node")+
  ggtitle("Change")
  
# DEGREE VS. DELTA 2
full %>%
  mutate(label = paste0("|", label, "|")) %>%
  filter(type == "After rewiring") %>%
  ggplot(aes(x = degree, y = abs(value)))+
  plotElements+
  xlab("Degree of removed node")+
  ggtitle("Recovery")
```

What about the ratio between the first and second changes? Aka: what percentage of the loss/gain is recovered by the rewiring?

```{r echo = FALSE, message = FALSE}
# Create the ratios data to use for these plots
deltaRatios <- full %>%
  group_by(run, name, number, degree, btwn, measure, label) %>%
  summarize(ratio = value[2]/value[1],
            absRatio = abs(ratio)) %>%
  mutate(measure = case_when(measure == "modu" ~ "Modularity",
                             measure == "dens" ~ "Density",
                             measure == "md" ~ "Mean Distance",
                             TRUE ~ NA_character_))

# Remove any that are too huge (above 200)
deltaRatios <- deltaRatios %>%
  filter(ratio < 200)

# Set some common plot elements
plotElements = list(geom_point(shape = 1),
             geom_smooth(method = "lm", aes(col = label)),
             scale_color_manual(values = c(mdColor, densColor, moduColor)),
             facet_wrap(~measure, scales = "free", strip.position = "left"),
             theme_minimal(),
             theme(strip.placement = "outside",
                   legend.position = "none",
                   axis.title.x = element_text(size = 14),
                   strip.text.y = element_text(size = 14)),
             ylab(""))

# DEGREE VS. DELTA RATIO
deltaRatios %>%
  ggplot(aes(x = degree, y = ratio))+
  plotElements+
  xlab("Degree of removed node")+
  ggtitle("Change/Recovery")

# DEGREE VS. abs(DELTA RATIO)
deltaRatios %>%
  ggplot(aes(x = degree, y = absRatio))+
  plotElements+
  xlab("Degree of removed node")+
  ggtitle("|Change/Recovery|")
```
