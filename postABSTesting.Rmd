---
title: "Post-ABS Testing"
author: "Kaija Gahm"
date: '2022-08-09'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, out.width = "100%")
```

```{r warning = FALSE, message = FALSE}
library(tidyverse)
library(gifski)
library(ggraph)
library(here)
library(igraph)
source(here("modelFunction_rewiring.R"))
```

First, run the model.

```{r}
# Define parameters
N = 50
edge.prob <- 0.04
burn.in = 20
burn.out = 5
pm = 0.3
ps = 0.1
pa = 0.2
add00 = c(0.5, 10)
lose01 = 0.1
add10 = 0.05
lose11 = c(0.5, 0.5)
histMultiplier = 1.2
doRemoval = TRUE
```

```{r}
modelGraphs <- runModel(N = N, # Nodes in the network
                        edge.prob = edge.prob, 
                        burn.in = burn.in,
                        burn.out = burn.out,
                        pm = pm,
                        ps = ps, 
                        pa = pa,
                        add00 = add00, 
                        lose01 = lose01, 
                        add10 = add10,
                        lose11 = lose11, 
                        histMultiplier = histMultiplier,
                        doRemoval = doRemoval) %>%
  lapply(., function(x){
    igraph::graph_from_adjacency_matrix(x, mode = "undirected", add.colnames = "label")
  })
```

1. How does variation in degree and betweenness emerge in this model?

Compute degree and betweenness for each of the model networks.
```{r}
attrDF <- lapply(modelGraphs, function(x){
  x %>%
    set_vertex_attr(., name = "degree", value = degree(x)) %>%
    set_vertex_attr(., name = "betweenness", value = betweenness(x)) %>%
    tidygraph::as_tbl_graph() %>%
    tidygraph::activate(nodes) %>%
    data.frame()
}) %>%
  data.table::rbindlist(idcol = "slice") %>%
  as.data.frame() %>%
  mutate(beforeAfter = ifelse(slice <= burn.in, "before", "after"))

# make a long-format version to use for facetted plots
attrDFLong <- attrDF %>%
  pivot_longer(cols = c(degree, betweenness), names_to = "measure", values_to = "value")
```

View degree and betweenness over time

```{r}
# Degree and betweenness over time
attrDFLong %>%
  ggplot(aes(x = slice, y = value, col = label, group = label))+
  facet_wrap(~measure, scales = "free")+
  geom_line(alpha = 0.7, size = 0.5)+
  theme_minimal()+
  geom_vline(xintercept = burn.in+1, col = "red", size = 1)+
  theme(legend.position = "none")

# Let's just look at a few labels, because this plot is too hard to read
indivs <- sample(unique(attrDFLong$label), 5)
attrDFLong %>%
  filter(label %in% indivs) %>%
  ggplot(aes(x = slice, y = value, col = label, group = label))+
  facet_wrap(~measure, scales = "free")+
  geom_line()+
  theme_minimal()+
  geom_vline(xintercept = burn.in+1, col = "red", size = 1)

# This is still a little hard to see... let's look at just the "before" rows.
attrDFLong %>%
  filter(label %in% indivs, beforeAfter == "before") %>%
  ggplot(aes(x = slice, y = value, col = label, group = label))+
  facet_wrap(~measure, scales = "free")+
  geom_line()+
  theme_minimal()

# Okay, I'm seeing some differentiation, but no clear patterns. Because of how the model is set up, the rank order tends to be maintained for a few consecutive time steps, but not over the whole span of the baseline model. This makes sense, since labels don't have any a priori reason to have higher or lower degrees than other labels.
```

Now, going to compute three network-level measures before and after the removal of an label.

### 1. Network density deltas

How does edge density behave over time?
```{r}
densities <- lapply(modelGraphs, function(x){
  edge_density(x)
}) %>% 
  unlist() %>% 
  as.data.frame() %>%
  setNames(., "density") %>%
  mutate(slice = 1:length(modelGraphs))

densities %>%
  ggplot(aes(x = slice, y = density))+
  geom_line()+
  theme_minimal()+
  geom_vline(aes(xintercept = burn.in+1), size = 1, col = "red")
```

First delta: immediately before removal to after removal/pre-rewiring
```{r}
delta1_density <- igraph::edge_density(modelGraphs[[burn.in+1]])-igraph::edge_density(modelGraphs[[burn.in]])
```

Second delta: after removal/pre-rewiring to post-rewiring
```{r}
delta2_density <- igraph::edge_density(modelGraphs[[burn.in+2]])-igraph::edge_density(modelGraphs[[burn.in+1]])
```

### 2. Network connectivity (average path length) deltas

How does connectivity behave over time?
```{r}
connectivities <- lapply(modelGraphs, function(x){
  mean_distance(x)
}) %>% 
  unlist() %>% 
  as.data.frame() %>%
  setNames(., "connectivity") %>%
  mutate(slice = 1:length(modelGraphs))

connectivities %>%
  ggplot(aes(x = slice, y = connectivity))+
  geom_line()+
  theme_minimal()+
  geom_vline(aes(xintercept = burn.in+1), size = 1, col = "red")
```

First delta: immediately before removal to after removal/pre-rewiring
```{r}
delta1_meanDistance <- igraph::mean_distance(modelGraphs[[burn.in+1]])-igraph::mean_distance(modelGraphs[[burn.in]])
```

Second delta: after removal/pre-rewiring to post-rewiring
```{r}
delta2_meanDistance <- igraph::mean_distance(modelGraphs[[burn.in+2]])-igraph::mean_distance(modelGraphs[[burn.in+1]])
```

### 3. Network modularity deltas

How does modularity behave over time?
```{r}
clustered <- lapply(modelGraphs, function(x){
  x %>%
    cluster_fast_greedy()
}) 

modularities <- data.frame(slice = 1:length(clustered),
                           modularity = unlist(lapply(clustered, modularity)),
                           nClusters = unlist(lapply(clustered, length)),
                           nIndivs = unlist(lapply(clustered, function(x){length(membership(x))})))

modularities %>%
  ggplot(aes(x = slice, y = modularity))+
  geom_line()+
  theme_minimal()+
  geom_vline(aes(xintercept = burn.in+1), size = 1, col = "red")

modularities %>%
  ggplot(aes(x = slice, y = nClusters))+
  geom_line()+
  theme_minimal()+
  geom_vline(aes(xintercept = burn.in+1), size = 1, col = "red")

modularities %>%
  ggplot(aes(x = slice, y = nClusters/modularity))+
  geom_line()+
  theme_minimal()+
  geom_vline(aes(xintercept = burn.in+1), size = 1, col = "red")
# there doesn't seem to be a pattern in the ratio of nClusters to modularity, but I will investigate on a larger scale.
```


Visually examine the clustering results to see if I see anything notable
```{r}
communities <- clustered[burn.in:(burn.in+2)]
graphs <- modelGraphs[burn.in:(burn.in+2)]

map2(.x = communities, .y = graphs, .f = function(.x, .y){
  plot(.x, .y, vertex.size = 5)
})

```

How does the clustering algorithm deal with isolated nodes?

Well, we know that there are clusters of size 1. So it looks like isolated nodes are being included.

What's the relationship between the number of isolated nodes vs. the number of clusters of size 1? In other words, how often, if ever, do we end up with a cluster of size 1 that is NOT an isolated node? I suspect that this graph is well-connected enough that this will never happen. I wonder under what conditions, if any, it would...

```{r}
nIsolatedNodes <- lapply(modelGraphs, function(x){
  sum(degree(x) == 0)
}) %>% unlist()

nSingletonClusters <- lapply(clustered, function(x){
  sum(sizes(x) == 1)
}) %>% unlist()

plot(nSingletonClusters ~ nIsolatedNodes) # okay yeah, there's a perfect relationship between these. This tells us that there are no cases in which we get a cluster of size 1 that is NOT an isolated node.
```

Let's examine what happens if we do the modularity calculations on networks with any isolated nodes removed!
```{r}
noIso <- lapply(modelGraphs, function(x){
  g <- delete_vertices(x, which(degree(x) == 0))
})
```

How does modularity behave over time when we remove isolated nodes?
```{r warning = FALSE}
clustered_noIso <- lapply(noIso, function(x){
  cluster_fast_greedy(x)
})

mods_noIso <- data.frame(slice = 1:length(clustered_noIso),
                         modularity = unlist(lapply(clustered_noIso, modularity)),
                         nClusters = unlist(lapply(clustered_noIso, length)),
                         nIndivs = unlist(lapply(clustered_noIso, function(x){length(membership(x))})))

mods_noIso %>%
  ggplot(aes(x = slice, y = modularity))+
  geom_line()+
  theme_minimal()+
  geom_vline(aes(xintercept = burn.in+1), size = 1, col = "red")+
  ggtitle("modularity over time, without isolated nodes")
```
This may look exactly the same as the above graph. That's because when N is large, there are hardly any isolated nodes.

First delta: immediately before removal to after removal/pre-rewiring
```{r}
delta1_modularity <- modularity(cluster_fast_greedy(modelGraphs[[burn.in+1]]))-modularity(cluster_fast_greedy(modelGraphs[[burn.in]]))
delta1_modularity_noIso <- modularity(cluster_fast_greedy(noIso[[burn.in+1]]))-modularity(cluster_fast_greedy(noIso[[burn.in]]))
```

Second delta: after removal/pre-rewiring to post-rewiring
```{r}
delta2_modularity <- modularity(cluster_fast_greedy(modelGraphs[[burn.in+2]]))-modularity(cluster_fast_greedy(modelGraphs[[burn.in+1]]))
delta2_modularity_noIso <- modularity(cluster_fast_greedy(noIso[[burn.in+2]]))-modularity(cluster_fast_greedy(noIso[[burn.in+1]]))
```

## What should our measure be?
I am not at all convinced that these momentary deltas are what I should be using. Seems like we need to at least consider two time steps out, since the model relies on this. Looking at the graphs above shows me how different the longer-term trends are from the short-term fluctuations.

Let's run the model 100 times and see if trends emerge in how to measure.
```{r}
nRuns <- 100
modelRuns <- vector(mode = "list", length = nRuns)
for(i in 1:nRuns){
  modelRuns[[i]] <- runModel(N = N, # Nodes in the network
                             edge.prob = edge.prob, 
                             burn.in = burn.in,
                             burn.out = burn.out,
                             pm = pm,
                             ps = ps, 
                             pa = pa,
                             add00 = add00, 
                             lose01 = lose01, 
                             add10 = add10,
                             lose11 = lose11, 
                             histMultiplier = histMultiplier,
                             doRemoval = doRemoval) %>%
    lapply(., function(x){
      igraph::graph_from_adjacency_matrix(x, mode = "undirected")
    })
}
```

# Compute the three network-level measures for each of the model runs.
```{r}
densList <- lapply(modelRuns, function(x){
  lapply(x, function(y){
    edge_density(y)
  }) %>%
    unlist() %>%
    as.data.frame() %>%
    setNames(., "density") %>%
    mutate(slice = 1:nrow(.))
})
densDF <- data.table::rbindlist(densList, idcol = "run")

connList <- lapply(modelRuns, function(x){
  lapply(x, function(y){
    mean_distance(y)
  }) %>%
    unlist() %>%
    as.data.frame() %>%
    setNames(., "connectivity") %>%
    mutate(slice = 1:nrow(.))
})
connDF <- data.table::rbindlist(connList, idcol = "run")

moduList <- lapply(modelRuns, function(x){
  clustered <- lapply(x, cluster_fast_greedy)
  df <- data.frame(slice = 1:length(clustered),
                   modularity = unlist(lapply(clustered, modularity)),
                   nClusters = unlist(lapply(clustered, length)),
                   nIndivs = unlist(lapply(clustered, function(i){length(membership(i))})))
  return(df)
})
moduDF <- data.table::rbindlist(moduList, idcol = "run")
```

Separate chunk for doing the calculations on the no-isolated-nodes graphs, so we don't unnecessarily suppress warnings for the other parts of the code.
```{r warning = FALSE}
modelRuns_noIso <- lapply(modelRuns, function(x){
  lapply(x, function(y){
    delete_vertices(y, which(degree(y) == 0))
  })
})
moduList_noIso <- lapply(modelRuns, function(x){
  noIso <- lapply(x, function(a){
    delete_vertices(a, which(degree(a) == 0))
  })
  clustered <- lapply(noIso, cluster_fast_greedy)
  df <- data.frame(slice = 1:length(clustered),
                   modularity = unlist(lapply(clustered, modularity)),
                   nClusters = unlist(lapply(clustered, length)),
                   nIndivs = unlist(lapply(clustered, function(i){length(membership(i))})))
  return(df)
})
moduDF_noIso <- data.table::rbindlist(moduList_noIso, idcol = "run")
```

Make some plots and try to detect any changepoint trends
```{r}
densDF %>%
  ggplot(aes(x = slice, y = density))+
  geom_line(aes(group = run, col = run), size = 0.1)+
  theme_minimal()+
  geom_vline(aes(xintercept = burn.in+1), size = 0.5, col = "red")+
  scale_color_viridis_c()

connDF %>%
  ggplot(aes(x = slice, y = connectivity))+
  geom_line(aes(group = run, col = run), size = 0.1)+
  theme_minimal()+
  geom_vline(aes(xintercept = burn.in+1), size = 0.5, col = "red")+
  scale_color_viridis_c()

moduDF %>%
  ggplot(aes(x = slice, y = modularity))+
  geom_line(aes(group = run, col = run), size = 0.1)+
  theme_minimal()+
  geom_vline(aes(xintercept = burn.in+1), size = 0.5, col = "red")+
  scale_color_viridis_c() +
  ggtitle("includes isolated nodes")

moduDF_noIso %>%
  ggplot(aes(x = slice, y = modularity))+
  geom_line(aes(group = run, col = run), size = 0.1)+
  theme_minimal()+
  geom_vline(aes(xintercept = burn.in+1), size = 0.5, col = "red")+
  scale_color_viridis_c()+
  ggtitle("no isolated nodes")
# This should look basically the same as the previous graph, since there are very few isolated nodes.
```

```{r}
moduDF %>%
  filter(slice > 3) %>%
  ggplot(aes(x = slice, y = nClusters))+
  geom_line(aes(group = run, col = run), size = 0.1)+
  theme_minimal()+
  geom_vline(aes(xintercept = burn.in+1), size = 0.5, col = "red")+
  scale_color_viridis_c()

moduDF %>%
  ggplot(aes(x = slice, y = modularity/nClusters))+
  geom_line(aes(group = run, col = run), size = 0.1)+
  theme_minimal()+
  geom_vline(aes(xintercept = burn.in+1), size = 0.5, col = "red")+
  scale_color_viridis_c()
# Absolutely no pattern at all in the ratio of clusters to modularity.
```

## 4. Relationship between removed node and network-level measures

```{r}
networkLevel <- left_join(densDF, connDF, by = c("run", "slice")) %>%
  left_join(moduDF, by = c("run", "slice"))

deltas <- networkLevel %>%
  filter(slice %in% c(burn.in, burn.in+1, burn.in+2)) %>%
  group_by(run) %>%
  summarize(dens1 = density[2]-density[1],
            dens2 = density[3]-density[2],
            conn1 = connectivity[2]-connectivity[1],
            conn2 = connectivity[3]-connectivity[2],
            modu1 = modularity[2]-modularity[1],
            modu2 = modularity[3]-modularity[2]) %>%
  pivot_longer(cols = -run, names_to = "measure", values_to = "value") %>%
  mutate(type = stringr::str_extract(measure, "[0-9]"),
         measure = stringr::str_remove(measure, "[0-9]")) %>%
  mutate(type = ifelse(type == 1, "Before rewiring", "After rewiring"))
  
# Info about the removed node
removedInfo <- lapply(modelRuns, function(x){
  init <- V(x[[1]])$name
  final <- V(x[[length(x)]])$name
  removedNumber <- which(!(init %in% final))
  removedName <- init[!(init %in% final)]
  removedDegree <- degree(x[[burn.in]])[removedNumber]
  removedBetweenness <- betweenness(x[[burn.in]])[removedNumber]
  df <- data.frame(name = removedName, number = removedNumber, 
                   degree = removedDegree,
                   btwn = removedBetweenness)
  return(df)
}) %>%
  data.table::rbindlist(idcol = "run") %>%
  as.data.frame()

# Combine individual-level and network-level info so we can compare them
full <- removedInfo %>%
  left_join(deltas, by = "run") %>%
  mutate(label = case_when(measure == "modu" ~ "\u0394 Modularity",
                           measure == "conn" ~ "\u0394 Connectivity (mean distance)",
                           measure == "dens" ~ "\u0394 Edge Density",
                           TRUE ~ NA_character_))
```

Okay, now that the data is prepared, let's graph it!
```{r}
# Degree and betweenness are probably highly correlated. Let's check.
removedInfo %>%
  ggplot(aes(x = degree, y = btwn))+
  geom_point(shape = 1)+
  geom_smooth(method = "lm")+
  theme_minimal()+
  ylab("Betweenness")+
  xlab("Degree")
```

They are indeed highly correlated. So we should expect very similar effects...
```{r}
# DEGREE VS. DELTA 1
full %>%
  filter(type == "Before rewiring") %>%
  ggplot(aes(x = degree, y = value))+
  geom_point(shape = 1)+
  geom_smooth(method = "lm", col = "blue")+
  facet_wrap(~label, scales = "free", strip.position = "left")+
  theme_minimal()+
  theme(strip.placement = "outside")+
  ylab("")+
  xlab("Degree of removed node")+
  ggtitle("Before rewiring")
  
# DEGREE VS. DELTA 2
full %>%
  filter(type == "After rewiring") %>%
  ggplot(aes(x = degree, y = value))+
  geom_point(shape = 1)+
  geom_smooth(method = "lm", col = "red")+
  facet_wrap(~label, scales = "free", strip.position = "left")+
  theme_minimal()+
  theme(strip.placement = "outside")+
  ylab("")+
  xlab("Degree of removed node")+
  ggtitle("After rewiring")

# BTWN VS. DELTA 1
full %>%
  filter(type == "Before rewiring") %>%
  ggplot(aes(x = btwn, y = value))+
  geom_point(shape = 1)+
  geom_smooth(method = "lm", col = "blue")+
  facet_wrap(~label, scales = "free", strip.position = "left")+
  theme_minimal()+
  theme(strip.placement = "outside")+
  ylab("")+
  xlab("Betweenness of removed node")+
  ggtitle("Before rewiring")
  
# BTWN VS. DELTA 2
full %>%
  filter(type == "After rewiring") %>%
  ggplot(aes(x = btwn, y = value))+
  geom_point(shape = 1)+
  geom_smooth(method = "lm", col = "red")+
  facet_wrap(~label, scales = "free", strip.position = "left")+
  theme_minimal()+
  theme(strip.placement = "outside")+
  ylab("")+
  xlab("Betweenness of removed node")+
  ggtitle("After rewiring")

```

What about the ratio between the first and second changes? Aka: what percentage of the loss/gain is recovered by the rewiring? Should be delta2/delta1.

```{r}
deltaRatios <- full %>%
  group_by(run, name, number, degree, btwn, measure, label) %>%
  summarize(ratio = value[2]/value[1],
            absRatio = abs(ratio))

# Remove any that are too huge (above 200)
deltaRatios <- deltaRatios %>%
  filter(ratio < 200)

# DEGREE VS. DELTA RATIO
deltaRatios %>%
  mutate(measure = case_when(measure == "modu" ~ "Modularity",
                             measure == "dens" ~ "Density",
                             measure == "conn" ~ "Connectivity",
                             TRUE ~ NA_character_)) %>%
  ggplot(aes(x = degree, y = ratio))+
  geom_point(shape = 1)+
  geom_smooth(method = "lm", col = "blue")+
  facet_wrap(~measure, scales = "free", strip.position = "left")+
  theme_minimal()+
  theme(strip.placement = "outside")+
  ylab("")+
  xlab("Degree of removed node")+
  ggtitle("Ratio of \u0394 after rewiring to \u0394 before rewiring")

# DEGREE VS. abs(DELTA RATIO)
deltaRatios %>%
  mutate(measure = case_when(measure == "modu" ~ "Modularity",
                             measure == "dens" ~ "Density",
                             measure == "conn" ~ "Connectivity",
                             TRUE ~ NA_character_)) %>%
  ggplot(aes(x = degree, y = absRatio))+
  geom_point(shape = 1)+
  geom_smooth(method = "lm", col = "blue")+
  facet_wrap(~measure, scales = "free", strip.position = "left")+
  theme_minimal()+
  theme(strip.placement = "outside")+
  ylab("")+
  xlab("Degree of removed node")+
  ggtitle("|Ratio of \u0394 after rewiring to \u0394 before rewiring|")

# BTWN VS. DELTA RATIO
deltaRatios %>%
  mutate(measure = case_when(measure == "modu" ~ "Modularity",
                             measure == "dens" ~ "Density",
                             measure == "conn" ~ "Connectivity",
                             TRUE ~ NA_character_)) %>%
  ggplot(aes(x = btwn, y = ratio))+
  geom_point(shape = 1)+
  geom_smooth(method = "lm", col = "blue")+
  facet_wrap(~measure, scales = "free", strip.position = "left")+
  theme_minimal()+
  theme(strip.placement = "outside")+
  ylab("")+
  xlab("Betweenness of removed node")+
  ggtitle("Ratio of \u0394 after rewiring to \u0394 before rewiring")

# BTWN VS. abs(DELTA RATIO)
deltaRatios %>%
  mutate(measure = case_when(measure == "modu" ~ "Modularity",
                             measure == "dens" ~ "Density",
                             measure == "conn" ~ "Connectivity",
                             TRUE ~ NA_character_)) %>%
  ggplot(aes(x = btwn, y = absRatio))+
  geom_point(shape = 1)+
  geom_smooth(method = "lm", col = "blue")+
  facet_wrap(~measure, scales = "free", strip.position = "left")+
  theme_minimal()+
  theme(strip.placement = "outside")+
  ylab("")+
  xlab("Betweenness of removed node")+
  ggtitle("|Ratio of \u0394 after rewiring to \u0394 before rewiring|")
```



