---
title: "Week 7 Progress Report"
author: "Kaija Gahm"
date: "5/12/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Load packages
```{r include = FALSE, echo = FALSE}
library(tidyverse)
library(igraph)
library(ggraph)
library(tidygraph)
library(data.table)
```

### Define some utility functions for later use
```{r}
# Function that searches for any nodes that are not connected at all to other nodes, and fills in one random edge (but only paying attention to the upper quadrant of the adjacency matrix)
connectIsolatedUpper <- function(mat){
  for(r in 1:(nrow(mat)-1)){
    for(c in 2:ncol(mat)){
      if(all(mat[r, c:ncol(mat)] == 0)){
        rand <- sample(c:ncol(mat), size = 1)
        mat[r, rand] <- 1
      }
    }
  }
  return(mat)
}

# Function to create and delete edges based on given probabilities.
# pNew is the probability of gaining an edge given that it doesn't exist. pLose is the probability of losing an existing edge.
switchfun <- function(x){
  switch <- runif(1)
  if(x == 0 & switch < pNew){
    return(1)
  }else if(x == 0 & switch >= pNew){
    return(0)
  }else if(x == 1 & switch < pLose){
    return(0)
  }else if(x == 1 & switch >= pLose){
    return(1)
  }
}
```


### Set some initial parameter values
```{r}
density <- 0.15 # initial density of the network (proportion of edges, out of all possible edges)
seed <- 3 # for reproducible results
remove <- 0.1 # probability of removing an edge, given that it exists
create <- 0.05 # probability of creating an edge, given that it doesn't exist
days <- 10 # how many days to run the simulation for.
```

### The main modeling function
```{r}
# MODEL:
# Returns a list of igraph network objects (graphs), one for each day in 1:tmax. 
# Graphs are BINARY and UNDIRECTED, based on the UPPER TRIANGLE of the adjacency matrix. 
runSim <- function(tmax = 10, # length of time over which to run the simulation
                   n = 50, # number of individuals
                   pNew = 0.1, # probability of gaining an edge given that it doesn't exist
                   pLose = 0.1, # probability of losing an edge given that it exists
                   allowIsolated = TRUE){ # allow nodes to be unconnected? If F, randomly connects each unconnected node with one other node.
  
  # STORAGE
  # Initialize lists to store graphs and ajacency matrices for each time step
  gs <- vector(mode = "list", length = tmax) # storage for graphs for each day--this will be the output.
  ams <- vector(mode = "list", length = tmax) # storage for adjacency matrices for each day

  # SETUP
  # Initialize the adjacency matrix for the first day
  amDay1 <- matrix(sample(0:1, n*n, replace = TRUE, prob = c(1-pNew, pNew)), n, n)
  if(allowIsolated == FALSE){
    amDay1 <- connectIsolatedUpper(amDay1)
  }
  ams[[1]] <- amDay1
  
  # RUN SIMULATION
  # Loop through the days
  for(day in 2:tmax){
    cat(paste("day", day, "\n")) # minimal feedback while running the model, for sanity check on speed
    previousAM <- ams[[day-1]] # previous day's matrix to operate on
    
    # Create this day's adjacency matrix
    newAM <- previousAM
    
    # For each edge, determine whether it is created, destroyed, or left alone.
    newAM <- apply(newAM, c(1,2), switchfun)
    
    # If we're not allowing isolated nodes, randomly connect each node one time.
    if(allowIsolated == FALSE){
      # Add a random edge for any isolated nodes, only paying attention to the upper triangle
      newAM <- connectIsolatedUpper(newAM)
    }
    
    # Save this day's adjacency matrix
    ams[[day]] <- newAM
  } # close day
  
  # Make each of the adjacency matrices into a graph, using only the upper triangle
  gs <- lapply(ams, function(x){
    graph_from_adjacency_matrix(x, mode = "upper", diag = FALSE)
  })
  
  return(gs)
}
```


























