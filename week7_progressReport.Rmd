---
title: "Week 7 Progress Report"
author: "Kaija Gahm"
date: "5/12/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Load packages
```{r include = FALSE, echo = FALSE}
library(tidyverse)
library(igraph)
library(ggraph)
library(tidygraph)
library(data.table)
```

### Define some utility functions for later use
```{r}
# FOR USE IN THE MODEL:
# Function that searches for any nodes that are not connected at all to other nodes, and fills in one random edge (but only paying attention to the upper quadrant of the adjacency matrix)
connectIsolatedUpper <- function(mat){
  for(r in 1:(nrow(mat)-1)){
    for(c in 2:ncol(mat)){
      if(all(mat[r, c:ncol(mat)] == 0)){
        rand <- sample(c:ncol(mat), size = 1)
        mat[r, rand] <- 1
      }
    }
  }
  return(mat)
}

# Get only unique edges (since we're dealing with an undirected graph)
uniqueEdges <- function(n){
  df <- expand.grid(from = 1:n, to = 1:n) %>%
    mutate(inOrder = case_when(from == to ~ NA_character_, 
                               from > to ~ paste(to, from),
                               from < to ~ paste(from, to))) %>%
    filter(!is.na(inOrder)) %>% # remove self edges
    group_by(inOrder) %>%
    slice(1) %>% # take only one edge for each
    ungroup() %>%
    select(-inOrder)
  return(df)
}

# FOR USE IN ANALYZING THE RESULTS:
# Make a bunch of plots to show change in the network over the model run
plotSim <- function(modelOutput, pointsize = 5, edgewidth = 0.2){
  # Create coords for plotting based on the first day's network
  coords <- layout_with_fr(modelOutput[[1]])
  
  lapply(modelOutput, function(x){
    x %>%
      ggraph(layout = coords)+
      geom_edge_link(edge_width = edgewidth)+
      geom_node_point(size = pointsize)
  })
}

# Get node-level stats for the model simulation output
getNodeStats <- function(modelOutput, type = "df"){
  # Check to make sure the "type" argument is valid
  if(!(type %in% c("df", "graphs", "list"))){
    stop("Argument 'type' must be 'df', 'graphs', or 'list'.")
  }
  
  # Calculate stats
  stats <- lapply(modelOutput, function(x){
    x %>% 
      as_tbl_graph() %>%
      activate(nodes) %>%
      mutate(centr = centrality_eigen(),
             deg = degree(.))
  })
  
  # Extract just the node data, making a list of data frames
  statsDFList <- lapply(stats, function(x){
    x %>% activate(nodes) %>% 
      as.data.frame()
  })
  
  # Compress the list of data frames into a single df
  statsDF <- data.table::rbindlist(statsDFList, idcol = "Day") %>% 
    as.data.frame()
  
  # Return different things based on what the user wants
  if(type == "df"){
    return(statsDF)
  }else if(type == "list"){
    return(statsDFList)
  }else if(type == "graphs"){
    return(stats)
  }
}
```

### The main modeling function
```{r}
# MODEL:
# Returns a list of igraph network objects (graphs), one for each day in 1:tmax. 
# Graphs are BINARY and UNDIRECTED, based on the UPPER TRIANGLE of the adjacency matrix. 
runSim <- function(tmax = 10, # length of time over which to run the simulation
                   n = 50, # number of individuals
                   pNew = 0.1, # probability of gaining an edge given that it doesn't exist
                   pLose = 0.1, # probability of losing an edge given that it exists
                   allowIsolated = TRUE){ # allow nodes to be unconnected? If F, randomly connects each unconnected node with one other node.
  
  # STORAGE
  # Initialize lists to store graphs and ajacency matrices for each time step
  gs <- vector(mode = "list", length = tmax) # storage for graphs for each day--this will be the output.
  ams <- vector(mode = "list", length = tmax) # storage for adjacency matrices for each day
  
  # SETUP
  # Initialize the adjacency matrix for the first day
  amDay1 <- matrix(sample(0:1, n*n, replace = TRUE, prob = c(1-pNew, pNew)), n, n) # using pNew here to determine the initial density of the network.
  if(allowIsolated == FALSE){
    amDay1 <- connectIsolatedUpper(amDay1)
  }
  cat("day 1\n")
  ams[[1]] <- amDay1
  
  # RUN SIMULATION
  # Loop through the days
  for(day in 2:tmax){
    cat(paste("day", day, "\n")) # minimal feedback while running the model, for sanity check on speed
    prev <- ams[[day-1]] # previous day's matrix to operate on
    prevG <- graph_from_adjacency_matrix(prev, mode = "upper", diag = FALSE)
    if(day < 3){
      prevprev <- matrix(0, n, n) # if we don't have enough info to get the am from two days ago, make a zeroes matrix.
    }else{
      prevprev <- ams[[day-2]]
    }
    prevprevG <- graph_from_adjacency_matrix(prevprev, mode = "upper", diag = FALSE)
    
    # pseudocode
    # 1. make a list of all the unique node pairs
    edges <- uniqueEdges(n)
    # 2. use get.edge.ids to search for the edge, using directed = FALSE
    edges <- edges %>%
      mutate(idInPrev = get.edge.ids(prevG, 
                                     vp = c(from, to), directed = F),
             idInPrevPrev = get.edge.ids(prevprevG, 
                                         vp = c(from, to), directed = F),
             dice = runif(1:nrow(edges))) %>%
      mutate(case = case_when(idInPrev == 0 & idInPrevPrev == 0 ~ "never",
                              idInPrev == 1 & idInPrevPrev == 0 ~ "recent",
                              idInPrev == 0 & idInPrevPrev == 1 ~ "lost",
                              idInPrev == 1 & idInPrevPrev == 1 ~ "always"))
    
    # 5. Four cases: found/found, found/not, not/not, and not/found. For each case, roll the dice. Use add_edges. Seems that when I add an edge to an undirected graph, it creates an undirected edge, which is good. delete_edges to remove edges.
    
    # For each edge, determine whether it is created, destroyed, or left alone.
    edges <- 
      newAM <- apply(prev, c(1,2), function(x, new = pNew, lose = pLose){
        switch <- runif(1)
        if(x == 0 & switch < new){
          return(1)
        }else if(x == 0 & switch >= new){
          return(0)
        }else if(x == 1 & switch < lose){
          return(0)
        }else if(x == 1 & switch >= lose){
          return(1)
        }
      })
    
    # If we're not allowing isolated nodes, randomly connect each node one time.
    if(allowIsolated == FALSE){
      # Add a random edge for any isolated nodes, only paying attention to the upper triangle
      newAM <- connectIsolatedUpper(newAM)
    }
    
    # Save this day's adjacency matrix
    ams[[day]] <- newAM
  } # close day
  
  # Make each of the adjacency matrices into a graph, using only the upper triangle
  gs <- lapply(ams, function(x){
    graph_from_adjacency_matrix(x, mode = "upper", diag = FALSE)
  })
  
  return(gs)
}
```

```{r}
test <- runSim(tmax = 10, n = 15)
```


