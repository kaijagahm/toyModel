---
title: "Week 7 Progress Report"
author: "Kaija Gahm"
date: "5/12/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Load packages
```{r include = FALSE, echo = FALSE}
library(tidyverse)
library(igraph)
library(ggraph)
library(tidygraph)
library(data.table)
```

### Define some utility functions for later use
```{r}
# FOR USE IN THE MODEL:
# Function that searches for any nodes that are not connected at all to other nodes, and fills in one random edge (but only paying attention to the upper quadrant of the adjacency matrix)
connectIsolatedUpper <- function(mat){
  for(r in 1:(nrow(mat)-1)){
    for(c in 2:ncol(mat)){
      if(all(mat[r, c:ncol(mat)] == 0)){
        rand <- sample(c:ncol(mat), size = 1)
        mat[r, rand] <- 1
      }
    }
  }
  return(mat)
}

# Get only unique edges (since we're dealing with an undirected graph)
uniqueEdges <- function(n){
  df <- expand.grid(from = 1:n, to = 1:n) %>%
    mutate(inOrder = case_when(from == to ~ NA_character_, 
                               from > to ~ paste(to, from),
                               from < to ~ paste(from, to))) %>%
    filter(!is.na(inOrder)) %>% # remove self edges
    group_by(inOrder) %>%
    slice(1) %>% # take only one edge for each
    ungroup() %>%
    select(-inOrder)
  return(df)
}

# FOR USE IN ANALYZING THE RESULTS:
# Make a bunch of plots to show change in the network over the model run
plotSim <- function(modelOutput, pointsize = 5, edgewidth = 0.2){
  # Create coords for plotting based on the first day's network
  coords <- layout_with_fr(modelOutput[[1]])
  
  lapply(modelOutput, function(x){
    x %>%
      ggraph(layout = coords)+
      geom_edge_link(edge_width = edgewidth)+
      geom_node_point(size = pointsize)
  })
}

# Get node-level stats for the model simulation output
getNodeStats <- function(modelOutput, type = "df"){
  # Check to make sure the "type" argument is valid
  if(!(type %in% c("df", "graphs", "list"))){
    stop("Argument 'type' must be 'df', 'graphs', or 'list'.")
  }
  
  # Calculate stats
  stats <- lapply(modelOutput, function(x){
    x %>% 
      as_tbl_graph() %>%
      activate(nodes) %>%
      mutate(centr = centrality_eigen(),
             deg = degree(.))
  })
  
  # Extract just the node data, making a list of data frames
  statsDFList <- lapply(stats, function(x){
    x %>% activate(nodes) %>% 
      as.data.frame()
  })
  
  # Compress the list of data frames into a single df
  statsDF <- data.table::rbindlist(statsDFList, idcol = "Day") %>% 
    as.data.frame()
  
  # Return different things based on what the user wants
  if(type == "df"){
    return(statsDF)
  }else if(type == "list"){
    return(statsDFList)
  }else if(type == "graphs"){
    return(stats)
  }
}
```

### The main modeling function
```{r}
# MODEL:
# Returns a list of igraph network objects (graphs), one for each day in 1:tmax. 
# Graphs are BINARY and UNDIRECTED, based on the UPPER TRIANGLE of the adjacency matrix. 
runSim <- function(tmax = 10, # length of time over which to run the simulation
                   n = 50, # number of individuals
                   pNew = 0.1, # probability of gaining an edge given that it doesn't exist
                   pLose = 0.1, # probability of losing an edge given that it exists
                   allowIsolated = TRUE, # allow nodes to be unconnected? If F, randomly connects each unconnected node with one other node.
                   baseAdd = 0.1, # p gain an edge given not connected in either of the previous two time steps
                   newLose = 0.3, # p lose an edge given connected in prev time step but not prev prev
                   lostAdd = 0.3, # p gain an edge given connected in prev prev time step but not prev
                   alwaysLose = 0.1){ # p lose edge given connected in previous 2 time steps)
  
  # STORAGE
  # Initialize lists to store graphs and ajacency matrices for each time step
  gs <- vector(mode = "list", length = tmax) # storage for graphs for each day--this will be the output.
  ams <- vector(mode = "list", length = tmax) # storage for adjacency matrices for each day
  
  # SETUP
  # Initialize the adjacency matrix for the first day
  amDay1 <- matrix(sample(0:1, n*n, replace = TRUE, prob = c(1-pNew, pNew)), n, n) # using pNew here to determine the initial density of the network.
  if(allowIsolated == FALSE){
    amDay1 <- connectIsolatedUpper(amDay1)
  }
  cat("day 1\n")
  ams[[1]] <- amDay1
  
  # RUN SIMULATION
  # Loop through the days
  for(day in 2:tmax){
    cat(paste("day", day, "\n")) # minimal feedback while running the model, for sanity check on speed
    prev <- ams[[day-1]] # previous day's matrix to operate on
    prevG <- graph_from_adjacency_matrix(prev, mode = "upper", diag = FALSE)
    if(day < 3){
      prevprev <- matrix(0, n, n) # if we don't have enough info to get the am from two days ago, make a zeroes matrix.
    }else{
      prevprev <- ams[[day-2]]
    }
    prevprevG <- graph_from_adjacency_matrix(prevprev, mode = "upper", diag = FALSE)
    
    # pseudocode
    # 1. make a list of all the unique node pairs
    edges <- uniqueEdges(n)
    # 2. use get.edge.ids to search for the edge, using directed = FALSE
    edges <- edges %>%
      mutate(idInPrev = get.edge.ids(prevG, 
                                     vp = c(from, to), directed = F),
             idInPrevPrev = get.edge.ids(prevprevG, 
                                         vp = c(from, to), directed = F),
             dice = runif(1:nrow(edges))) %>% # roll the dice for each individual edge
      # characterize the type of relationship between each pair of nodes
      mutate(case = case_when(idInPrev == 0 & idInPrevPrev == 0 ~ "never",
                              idInPrev != 0 & idInPrevPrev == 0 ~ "new",
                              idInPrev == 0 & idInPrevPrev != 0 ~ "lost",
                              idInPrev != 0 & idInPrevPrev != 0 ~ "always",
                              TRUE ~ "error"))
    
    # Rules (note that "stay" is comprehensible but not actionable, so I've translated it into ADD/LOSE)
    edges <- edges %>%
      mutate(action = case_when(case == "never" & dice <= baseAdd ~ "add",
                                case == "never" & dice > baseAdd ~ "nothing",
                                case == "new" & dice <= newLose ~ "lose",
                                case == "new" & dice > newLose ~ "nothing",
                                case == "lost" & dice <= lostAdd ~ "add",
                                case == "lost" & dice > lostAdd ~ "nothing",
                                case == "always" & dice <= alwaysLose ~ "lose",
                                case == "always" & dice > alwaysLose ~ "nothing",
                                TRUE ~ "error"))
    
    # Loop through the edges and operate on them
    newG <- prevG # initialize new graph
    for(edge in 1:nrow(edges)){
      pair <- c(edges[edge, "from"], edges[edge, "to"])
      if(edges[edge, "action"] == "add"){
        newG <- add_edges(graph = newG, edges = pair)
      }else if(edges[edge, "action"] == "lose"){
        newG <- delete_edges(graph = newG, edges = pair)
      }else{
        newG <- newG
      }
    }
    
    # START HERE: find a way to do the adding of nodes via igraph add_edges. Can then eliminate adjacency matrices entirely.
    # If we're not allowing isolated nodes, randomly connect each node one time.
    if(allowIsolated == FALSE){
      # Add a random edge for any isolated nodes, only paying attention to the upper triangle
      newAM <- connectIsolatedUpper(newAM)
    }
    
    # Save this day's adjacency matrix
    ams[[day]] <- newAM
  } # close day
  
  # Make each of the adjacency matrices into a graph, using only the upper triangle
  gs <- lapply(ams, function(x){
    graph_from_adjacency_matrix(x, mode = "upper", diag = FALSE)
  })
  
  return(gs)
}
```

```{r}
test <- runSim(tmax = 10, n = 15)
```


