---
title: "Week 7 Progress Report"
author: "Kaija Gahm"
date: "5/12/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Load packages
```{r include = FALSE, echo = FALSE}
library(tidyverse)
library(igraph)
library(ggraph)
library(tidygraph)
library(data.table)
```

### Define some utility functions for later use
```{r}
# FOR USE IN THE MODEL:
# Function that searches for any nodes that are not connected at all to other nodes, and fills in one random edge (but only paying attention to the upper quadrant of the adjacency matrix)
connectIsolatedUpper <- function(mat){
  for(r in 1:(nrow(mat)-1)){
    for(c in 2:ncol(mat)){
      if(all(mat[r, c:ncol(mat)] == 0)){
        rand <- sample(c:ncol(mat), size = 1)
        mat[r, rand] <- 1
      }
    }
  }
  return(mat)
}

# FOR USE IN ANALYZING THE RESULTS:
# Make a bunch of plots to show change in the network over the model run
plotSim <- function(modelOutput, pointsize = 5, edgewidth = 0.2){
  # Create coords for plotting based on the first day's network
  coords <- layout_with_fr(modelOutput[[1]])
  
  lapply(modelOutput, function(x){
    x %>%
      ggraph(layout = coords)+
      geom_edge_link(edge_width = edgewidth)+
      geom_node_point(size = pointsize)
  })
}

# Get node-level stats for the model simulation output
getNodeStats <- function(modelOutput, type = "df"){
  # Check to make sure the "type" argument is valid
  if(!(type %in% c("df", "graphs", "list"))){
    stop("Argument 'type' must be 'df', 'graphs', or 'list'.")
  }
  
  # Calculate stats
  stats <- lapply(modelOutput, function(x){
    x %>% 
      as_tbl_graph() %>%
      activate(nodes) %>%
      mutate(centr = centrality_eigen(),
             deg = degree(.))
  })
  
  # Extract just the node data, making a list of data frames
  statsDFList <- lapply(stats, function(x){
    x %>% activate(nodes) %>% 
      as.data.frame()
  })
  
  # Compress the list of data frames into a single df
  statsDF <- data.table::rbindlist(statsDFList, idcol = "Day") %>% 
    as.data.frame()
  
  # Return different things based on what the user wants
  if(type == "df"){
    return(statsDF)
  }else if(type == "list"){
    return(statsDFList)
  }else if(type == "graphs"){
    return(stats)
  }
}
```

### The main modeling function
```{r}
# MODEL:
# Returns a list of igraph network objects (graphs), one for each day in 1:tmax. 
# Graphs are BINARY and UNDIRECTED, based on the UPPER TRIANGLE of the adjacency matrix. 
runSim <- function(tmax = 10, # length of time over which to run the simulation
                   n = 50, # number of individuals
                   pNew = 0.1, # probability of gaining an edge given that it doesn't exist
                   pLose = 0.1, # probability of losing an edge given that it exists
                   allowIsolated = TRUE){ # allow nodes to be unconnected? If F, randomly connects each unconnected node with one other node.
  
  # STORAGE
  # Initialize lists to store graphs and ajacency matrices for each time step
  gs <- vector(mode = "list", length = tmax) # storage for graphs for each day--this will be the output.
  ams <- vector(mode = "list", length = tmax) # storage for adjacency matrices for each day
  
  # SETUP
  # Initialize the adjacency matrix for the first day
  amDay1 <- matrix(sample(0:1, n*n, replace = TRUE, prob = c(1-pNew, pNew)), n, n) # using pNew here to determine the initial density of the network.
  if(allowIsolated == FALSE){
    amDay1 <- connectIsolatedUpper(amDay1)
  }
  ams[[1]] <- amDay1
  
  # RUN SIMULATION
  # Loop through the days
  for(day in 2:tmax){
    cat(paste("day", day, "\n")) # minimal feedback while running the model, for sanity check on speed
    previousAM <- ams[[day-1]] # previous day's matrix to operate on
    
    # Create this day's adjacency matrix
    newAM <- previousAM
    
    # For each edge, determine whether it is created, destroyed, or left alone.
    newAM <- apply(newAM, c(1,2), function(x, new = pNew, lose = pLose){
      switch <- runif(1)
      if(x == 0 & switch < new){
        return(1)
      }else if(x == 0 & switch >= new){
        return(0)
      }else if(x == 1 & switch < lose){
        return(0)
      }else if(x == 1 & switch >= lose){
        return(1)
      }
    })
    
    # If we're not allowing isolated nodes, randomly connect each node one time.
    if(allowIsolated == FALSE){
      # Add a random edge for any isolated nodes, only paying attention to the upper triangle
      newAM <- connectIsolatedUpper(newAM)
    }
    
    # Save this day's adjacency matrix
    ams[[day]] <- newAM
  } # close day
  
  # Make each of the adjacency matrices into a graph, using only the upper triangle
  gs <- lapply(ams, function(x){
    graph_from_adjacency_matrix(x, mode = "upper", diag = FALSE)
  })
  
  return(gs)
}
```


























