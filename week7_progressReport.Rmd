---
title: "Week 7 Progress Report"
author: "Kaija Gahm"
date: "5/12/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Load packages
```{r include = FALSE, echo = FALSE}
library(tidyverse)
library(igraph)
library(ggraph)
library(tidygraph)
library(data.table)
```

### Define some utility functions for later use
```{r}
# FOR USE IN THE MODEL:
# Function that searches for any nodes that are not connected at all to other nodes, and attaches them to one other node at random.
connectIsolatedNodes <- function(g, allow){
  if(any(degree(g) == 0) & allow == FALSE){
    isolatedNodes <- which(degree(g) == 0)
    gOut <- g
    for(focalNode in isolatedNodes){
      gOut <- add_edges(gOut, 
                        edges = c(focalNode, #from the focal node...
                                  #...to any other node
                                  sample((1:n)[-focalNode], # (but not self!)
                                         size = 1)))
    }
    return(gOut)
  }else{
    return(g) # pass the graph through as it is, if there are no isolated nodes
  }
}

# Get only unique edges (since we're dealing with an undirected graph)
uniqueEdges <- function(n){
  df <- expand.grid(from = 1:n, to = 1:n) %>%
    mutate(inOrder = case_when(from == to ~ NA_character_, 
                               from > to ~ paste(to, from),
                               from < to ~ paste(from, to))) %>%
    filter(!is.na(inOrder)) %>% # remove self edges
    group_by(inOrder) %>%
    slice(1) %>% # take only one edge for each
    ungroup() %>%
    select(-inOrder)
  return(df)
}

# FOR USE IN ANALYZING THE RESULTS:
# Make a bunch of plots to show change in the network over the model run
plotSim <- function(modelOutput, pointsize = 5, edgewidth = 0.2){
  # Create coords for plotting based on the first day's network
  coords <- layout_with_fr(modelOutput[[1]])
  
  return(lapply(modelOutput, function(x){
    x %>%
      ggraph(layout = coords)+
      geom_edge_link(edge_width = edgewidth)+
      geom_node_point(size = pointsize)
  }))
}

# Get node-level stats for the model simulation output
getNodeStats <- function(modelOutput, type = "df"){
  # Check to make sure the "type" argument is valid
  if(!(type %in% c("df", "graphs", "list"))){
    stop("Argument 'type' must be 'df', 'graphs', or 'list'.")
  }
  
  # Calculate stats
  stats <- lapply(modelOutput, function(x){
    x %>% 
      as_tbl_graph() %>%
      activate(nodes) %>%
      mutate(centr = centrality_eigen(),
             deg = degree(.))
  })
  
  # Extract just the node data, making a list of data frames
  statsDFList <- lapply(stats, function(x){
    x %>% activate(nodes) %>% 
      as.data.frame()
  })
  
  # Compress the list of data frames into a single df
  statsDF <- data.table::rbindlist(statsDFList, idcol = "Day") %>% 
    as.data.frame()
  
  # Return different things based on what the user wants
  if(type == "df"){
    return(statsDF)
  }else if(type == "list"){
    return(statsDFList)
  }else if(type == "graphs"){
    return(stats)
  }
}
```

### The main modeling function
```{r}
# MODEL:
# Returns a list of igraph network objects (graphs), one for each day in 1:tmax. 
# Graphs are BINARY and UNDIRECTED, based on the UPPER TRIANGLE of the adjacency matrix. 
runSim <- function(tmax = 10, # length of time over which to run the simulation
                   n = 50, # number of individuals
                   allowIsolated = FALSE, # allow nodes to be unconnected? If F, randomly connects each unconnected node with one other node.
                   baseAdd = 0.1, # p gain an edge given not connected in either of the previous two time steps
                   newLose = 0.3, # p lose an edge given connected in prev time step but not prev prev
                   lostAdd = 0.3, # p gain an edge given connected in prev prev time step but not prev
                   alwaysLose = 0.1,
                   verbose = TRUE){ # p lose edge given connected in previous 2 time steps)
  # STORAGE
  # Initialize lists to store graphs and ajacency matrices for each time step
  gs <- vector(mode = "list", length = tmax) # storage for graphs for each day--this will be the output.
  ei <- vector(mode = "list", length = tmax) # store edge info for each day
  
  # Make a list of all the unique node pairs
  edges <- uniqueEdges(n)
  
  # SETUP
  # Create the graph for the first day
  startingEdges <- edges %>%
    sample_n(size = nrow(edges)*baseAdd) # sample some edges based on the probability of creating edges out of nowhere
  day1G <- graph_from_data_frame(startingEdges, directed = FALSE, vertices = 1:n)
  
  # Deal with isolated nodes
  # The connectIsolatedNodes function has a built-in switch based on the allowIsolated parameter.
  day1G <- connectIsolatedNodes(g = day1G, allow = allowIsolated)
  gs[[1]] <- day1G
  
  # RUN SIMULATION
  # Loop through the days
  progress <- 0 # initialize progress indicator
  cat("0%\n")
  for(day in 2:tmax){
    if(verbose){
          cat(paste("day", day, "\n")) # minimal feedback while running the model, for sanity check on speed
    }
    
    prevG <- gs[[day-1]] # previous day's matrix to operate on
    if(day < 3){
      prevprevG <- graph_from_adjacency_matrix(matrix(0, n, n), mode = "upper", diag = FALSE) # if we don't have enough info to get the am from two days ago, make a zeroes graph
    }else{
      prevprevG <- gs[[day-2]]
    }
    
    # Use get.edge.ids to search for the edge, using directed = FALSE
    # Annoyingly, have to use a for loop with get.edge.ids--returns mysterious weird results if I try to use it with mutate. Not sure why. I wonder if there's a vectorized alternative in tidygraph. Need to investigate this further.
    edgesInfo <- edges
    edgesInfo$idInPrevPrev <- NA
    edgesInfo$idInPrev <- NA
    for(edge in 1:nrow(edges)){
      from <- edges[edge, "from"]
      to <- edges[edge, "to"]
      edgesInfo$idInPrevPrev[edge] <- get.edge.ids(prevprevG, 
                                         vp = c(from, to), directed = F)
      edgesInfo$idInPrev[edge] <- get.edge.ids(prevG, 
                                     vp = c(from, to), directed = F)
    }
    edgesInfo <- edgesInfo %>% mutate(rand = runif(n = nrow(edges), 
                                                   min = 0, max = 1)) %>% # draw random number for each individual edge
      # characterize the type of relationship between each pair of nodes
      mutate(case = case_when(idInPrev == 0 & idInPrevPrev == 0 ~ "never",
                              idInPrev != 0 & idInPrevPrev == 0 ~ "new",
                              idInPrev == 0 & idInPrevPrev != 0 ~ "lost",
                              idInPrev != 0 & idInPrevPrev != 0 ~ "always",
                              TRUE ~ "error"))
    
    # Error message just in case!
    if(any(edgesInfo$case == "error")){
      stop("error computing edge cases!")
    }
    
    # Rules (note that "stay" is comprehensible but not actionable, so I've translated it into ADD/LOSE)
    edgesInfo <- edgesInfo %>%
      mutate(action = case_when(case == "never" & rand <= baseAdd ~ "add",
                                case == "never" & rand > baseAdd ~ "none",
                                case == "new" & rand <= newLose ~ "lose",
                                case == "new" & rand > newLose ~ "none",
                                case == "lost" & rand <= lostAdd ~ "add",
                                case == "lost" & rand > lostAdd ~ "none",
                                case == "always" & rand <= alwaysLose ~ "lose",
                                case == "always" & rand > alwaysLose ~ "none",
                                TRUE ~ "error"))
    
    # Error message just in case!
    if(any(edgesInfo$action == "error")){
      stop("error computing edge actions!")
    }
    
    # Loop through the edges and operate on them
    # Idea for later: df[,c("from", "to")] %>% as.matrix() %>% t() %>% as.vector() to be fed into add_edges so I can do them all at once (assuming that df is edgesInfo %>% filter(action == "add)). But no point in refactoring the code to do this right now since it turns out it doesn't work for delete_edges.
    newG <- prevG # initialize new graph
    for(edge in 1:nrow(edgesInfo)){
      pair <- c(edgesInfo[edge, "from"], edgesInfo[edge, "to"])
      if(edgesInfo[edge, "action"] == "add"){
        newG <- add_edges(graph = newG, edges = pair)
      }else if(edgesInfo[edge, "action"] == "lose"){
        edgeID <- get.edge.ids(newG, vp = pair, directed = F) # XXXXXXXXXXXX
        newG <- delete_edges(graph = newG, edgeID) # XXX UNBELIEVABLE--WHY DOES DELETE_EDGES WORK DIFFERENTLY THAN ADD_EDGES??????
      }else{
        newG <- newG
      }
      # print(paste0("iteration ", edge, " complete")) # for debug
    }
    
    # If we're not allowing isolated nodes, randomly connect each node one time.
    newG <- connectIsolatedNodes(g = newG, allow = allowIsolated)
    
    # Save this day's graph
    gs[[day]] <- newG
    # Save this day's edge info
    ei[[day]] <- edgesInfo
    if((day/tmax) >= progress + 0.1){
      progress <- day/tmax
      cat(paste0(progress*100, "%\n"))
    }
  } # close day
  
  return(list("gs" = gs, "ei" = ei))
}
```

### Test-run the simulation and plot the results
```{r}
test <- runSim(tmax = 10, n = 15, allowIsolated = FALSE, verbose = FALSE)
plotSim(test$g)
```
### Another test with a longer time frame: 50 days
```{r}
test1000 <- runSim(tmax = 1000, n = 15, allowIsolated = FALSE, verbose = FALSE)
```

### Examine temporal dynamics
```{r}
stats <- getNodeStats(test100$gs, type = "df")
head(stats)
stats %>%
  ggplot(aes(x = Day, y = deg))+
  geom_point(alpha = 0.1)+
  geom_smooth()+
  theme_minimal()
```

